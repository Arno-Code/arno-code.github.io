<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://blog.leoz.space/</id><title>Leoz's Awesome Blogs</title><subtitle>java,js,mysql,vue,redis,mq.</subtitle> <updated>2025-07-24T11:56:27+08:00</updated> <author> <name>leoz</name> <uri>https://blog.leoz.space/</uri> </author><link rel="self" type="application/atom+xml" href="https://blog.leoz.space/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://blog.leoz.space/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2025 leoz </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>mybatis-plus踩坑日记</title><link href="https://blog.leoz.space/posts/mybatis-plus%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/" rel="alternate" type="text/html" title="mybatis-plus踩坑日记" /><published>2022-10-10T14:10:00+08:00</published> <updated>2022-10-11T09:30:42+08:00</updated> <id>https://blog.leoz.space/posts/mybatis-plus%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/</id> <content src="https://blog.leoz.space/posts/mybatis-plus%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/" /> <author> <name>leoz</name> </author> <category term="踩坑日记" /> <category term="持久层" /> <summary> content mybatis-plus踩坑日记 mybatis-plus的@TableField注解中的exist属性默认为true，如果数据库中没有对应的字段，会报错。 mybatis-plus的@TableLogic注解修饰的字段不能通过updateById修改。 </summary> </entry> <entry><title>研读MySQL02之事务原理与锁机制</title><link href="https://blog.leoz.space/posts/mysql-tx-lock/" rel="alternate" type="text/html" title="研读MySQL02之事务原理与锁机制" /><published>2022-01-22T11:33:00+08:00</published> <updated>2022-03-03T17:44:21+08:00</updated> <id>https://blog.leoz.space/posts/mysql-tx-lock/</id> <content src="https://blog.leoz.space/posts/mysql-tx-lock/" /> <author> <name>{"name"=>"Leoz", "link"=>"https://gitee.com/Arno-Code"}</name> </author> <category term="中间件" /> <category term="数据库" /> <summary> 事务原理 事务特性 隔离级别 并发问题 当前读和快照读 MVCC ReadView undo log redo log 锁机制 行级锁 间隙锁 表级锁 死锁的分析 事务原理 事务特性 A（Atomicity原子性）：全部成功或全部失败 I（Isolation隔离性）：并行事务之间，互不干扰 D（Durability持久性）：事务提交后，永久生效 C（Consistency一致性）：通过 AID 保证 隔离级别 Read Uncommitted（读未提交）：最低隔离级别，会读取到其他事务未提交的数据 即其他事务update操作commit之前，它就能... </summary> </entry> <entry><title>研读MySQL01之存储原理与索引实现</title><link href="https://blog.leoz.space/posts/mysql-page-index/" rel="alternate" type="text/html" title="研读MySQL01之存储原理与索引实现" /><published>2022-01-21T11:33:00+08:00</published> <updated>2022-03-03T17:44:21+08:00</updated> <id>https://blog.leoz.space/posts/mysql-page-index/</id> <content src="https://blog.leoz.space/posts/mysql-page-index/" /> <author> <name>{"name"=>"Leoz", "link"=>"https://gitee.com/Arno-Code"}</name> </author> <category term="中间件" /> <category term="数据库" /> <summary> 存储原理 数据页 插入策略 顺序保证 页内查询 索引实现 聚簇索引 二级索引 联合索引 最左匹配原则 索引区分度 覆盖索引 索引下推 外置索引 索引失效 存储原理 数据页 MySQL 从磁盘装载数据到内存时，是以页为单位的，一次装载一个或多个 Page 下图就是 MySQL 内存里面一页数据的结构（一个页的大小固定为16KB） 页头：记录页面的控制信息，共 56 字节，包括相邻页面指针（页与页会组成一个双向链表）、页面空间使用情况等 虚记录：其本身不存储数据，它记录了这... </summary> </entry> <entry><title>研习RocketMQ03之事务消息与延时消息</title><link href="https://blog.leoz.space/posts/rocketmq-tx-delay/" rel="alternate" type="text/html" title="研习RocketMQ03之事务消息与延时消息" /><published>2022-01-03T11:33:00+08:00</published> <updated>2022-03-03T17:44:21+08:00</updated> <id>https://blog.leoz.space/posts/rocketmq-tx-delay/</id> <content src="https://blog.leoz.space/posts/rocketmq-tx-delay/" /> <author> <name>{"name"=>"Leoz", "link"=>"https://gitee.com/Arno-Code"}</name> </author> <category term="中间件" /> <category term="消息队列" /> <summary> 事务消息 实现流程 核心原理 缺点 自定义实现 延时消息 缺点 事务消息 实现流程 上图为 RocketMQ 事务消息实现流程，也是基于两阶段提交协议（2PC） HALF消息 MQ 收到一条事务消息后：会将该事务消息的主题和队列信息，转换成，半消息储存起来 然后放到RMQ_SYS_TRANS_HALF_TOPIC里面，而该topic对consumer是不可见的，所以半消息不会被订阅和消费 OP消息 MQ收到针对事务消息的commit或rollback时，会将其储存在RMQ_SYS_TRANS_OP_HALF_TOPIC里面 然后，若是rollback，则只做记录；若是commit，则根据HALF消息还原事务消息内容并投递出去（投递到commit... </summary> </entry> <entry><title>研习RocketMQ02之生产消费与负载均衡</title><link href="https://blog.leoz.space/posts/rocketmq-data-ha/" rel="alternate" type="text/html" title="研习RocketMQ02之生产消费与负载均衡" /><published>2022-01-02T11:33:00+08:00</published> <updated>2022-03-03T17:44:21+08:00</updated> <id>https://blog.leoz.space/posts/rocketmq-data-ha/</id> <content src="https://blog.leoz.space/posts/rocketmq-data-ha/" /> <author> <name>{"name"=>"Leoz", "link"=>"https://gitee.com/Arno-Code"}</name> </author> <category term="中间件" /> <category term="消息队列" /> <summary> 生产与消费 生产方式 消费方式 集群消费 负载均衡 Producer端负载均衡 Consumer端负载均衡 生产与消费 生产方式 producer有三种生产消息的方式 同步（sync）：消息投递出去之后，broker同步返回成功或失败 异步（async）：消息投递出去之后，不用等结果，自己写一个callback来接收投递结果 单向（oneway）：就是啥也不管，无脑投递 这里实际是要结合broker的刷盘方式，来看用哪种生产方式（多方配合） 消费方式 消费方式一般分为推和拉两种 PUSH：消息队列主动将消息推给消费者（优点是消息实时性高，缺点是忽略了客户端的消费能力） PULL：消费者主动向消息队列拉取消息（缺点是消息实时性... </summary> </entry> </feed>
