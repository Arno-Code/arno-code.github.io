[ { "title": "mybatis-plus踩坑日记", "url": "/posts/mybatis-plus%E6%97%A5%E5%B8%B8%E8%B8%A9%E5%9D%91/", "categories": "踩坑日记, 持久层", "tags": "mybatis-plus", "date": "2022-10-10 14:10:00 +0800", "snippet": " contentmybatis-plus踩坑日记 mybatis-plus的@TableField注解中的exist属性默认为true，如果数据库中没有对应的字段，会报错。 mybatis-plus的@TableLogic注解修饰的字段不能通过updateById修改。 " }, { "title": "研读MySQL02之事务原理与锁机制", "url": "/posts/mysql-tx-lock/", "categories": "中间件, 数据库", "tags": "MySQL", "date": "2022-01-22 11:33:00 +0800", "snippet": " 事务原理 事务特性 隔离级别 并发问题 当前读和快照读 MVCC ReadView undo log redo log 锁机制 行级锁 间隙锁 表级锁 死锁的分析 事务原理事务特性 A（Atomicity原子性）：全部成功或全部失败 I（Isolation隔离性）：并行事务之间，互不干扰 D（Durability持久性）：事务提交后，永久生效 C（Consistency一致性）：通过 AID 保证隔离级别 Read Uncommitted（读未提交）：最低隔离级别，会读取到其他事务未提交的数据即其他事务update操作commit之前，它就能读到update之后的结果，若最后update回滚了，那它又读到之前的结果 Read Committed（读已提交）：事务过程中可以读取到其他事务已提交的数据这是Oracle默认隔离级别，即只要其他事务未commit，那读到的都是之前的结果，只有commit后读到的才是新结果 Repeatable Read（可重复读）：每次读取相同结果集，不管其他事务是否提交这是MySQL默认隔离级别，是依赖MVCC（Multi-Version Concurrent Control，多版本并发控制）实现的快照读 Serializable（可串行化）：事务排队，隔离级别最高，性能最差，也是最严格的隔离级别并发问题不同的隔离级别，会引发不同的并发问题，下面是常见的三种： 脏读（Drity Read）：读取到未提交的数据 不可重复读（Non-repeatable read）：两次读取结果不同 幻读（Phantom Read）：读到的结果所表征的数据状态无法支撑后续的业务操作通过隔离级别的特性，可以知道： RC解决了脏读，但是，它会引起不可重复读和幻读（Oracle） RR解决了脏读和不可重复读，但是，它会引起幻读（MySQL） 幻读通常是针对 insert 来说的比如 select 某记录发现不存在，接着插入该记录，但插入时发现记录又存在了，插入失败，这就是发生了幻读而 mysql 为了解决幻读，提出了 LBCC（解决当前读下的幻读）和 MVCC（解决快照读下的幻读）的两种方案当前读和快照读我们通过 select 读数据库的时候，实际上有两种读：当前读 和 快照读 当前读：读取的是数据的最新版本，并对读取的记录加锁（所以会阻塞其他事务同时改动该记录）　　　　这两个语句都是当前读：select…lock in share mode / select…for update　　　　另外，对于数据修改的操作（insert/update/delete），也是采用的当前读　　　　比如说，我们在 update 的时候，首先会执行当前读，然后把返回的数据加锁，接着才是执行 update 快照读：单纯的 select 操作，不包括上述的 select…lock in share mode/select…for update/insert/update/delete　　　　其读取的是数据的可见版本（可能是过期的数据），且不会加锁而当前读和快照读的具体读法，以及快照读又是如何在众多快照中读到数据的，就涉及到了 MVCC 理论MVCC正常来讲，既有读又有写操作的时候，是要加锁的而现在很多数据库都支持 MVCC（Multi-Version Concurrent Control，多版本并发控制）理论这样就不用加锁了，变成你写你的版本，我读老的版本，彼此不碍事（类似于 Java Concurrent 包中的 CopyOnWrite）所以说 MVCC 不光解决了隔离级别的问题，实际上它也解决了事务并发的问题（即读写不冲突）MySQL 同样支持 MVCC 理论，它是在每条记录上都添加隐藏列的方式实现的并借助 undo log 和 redo log 实现了事务控制（binlog 是数据库层面的同步和恢复用的）比如修改了一条记录，该记录中会有版本号和回滚指针两个隐藏列，回滚指针指向 undo log 中的上一次修改的记录而上一次的记录中，可能又有回滚指针指向再上一次的记录，故无论修改多少次，都可以从 undo log 中读到数据如下图所示：select for update 是一个典型的当前读，它始终读取最新版本的数据其中 DB_TRX_ID 和 DB_ROLL_PTR 是两个隐藏列一个代表事务ID（mysql 的每个事务都会分配一个全局唯一且递增的ID），相当于是标识这条数据的版本号另一个就相当于这条数据的一个指针，它指向这条数据的前一个版本这样，数据的多版本和控制就有了而作为快照读的普通 select，怎么决定具体读哪个版本呢，这就涉及到 ReadView 机制ReadViewInnoDB 会为每个事务都构造一个数组，用来保存该事务启动的瞬间，当前正在 【活跃】 的所有事务ID活跃事务指的是启动了但还没提交的事务，另外还有 低水位 和 高水位 的概念： 低水位：该数组中的最小ID 高水位：创建数组时，系统尚未分配的下一个事务ID，也即目前已创建过的事务ID的最大值 + 1（不是数组中的）而这个数组加上高水位，就组成了当前事务的一致性视图，即 ReadView所以说 ReadView 就是一个保存了事务ID的列表与其相关的，有 4 个比较重要的定义： m_ids：生成ReadView时当前系统中活跃的读写事务的事务ID列表 min_trx_id：低水位 max_trx_id：高水位 creator_trx_id：生成该ReadView的事务的事务ID按照 RR 的定义：一个事务启动时，能看到所有已提交的事务结果，但该事务执行期间，其他事务的更新对它不可见换言之，一个事务只需要在启动的时候说，以我启动的时刻为准，如果一个数据的版本是在我启动之前生成的，我就认若在我启动之后才生成的，我就不认，这时我必须找到它的上一个版本，如果 “上一个版本” 也不可见，则继续往前找还有，如果是这个事务自己更新的数据，它自己还是要认的（也就是说：我能读到比我先的，不能读到比我后的）而这，正是通过 ReadView 来做数据可见性判断的思路如下图所示：实际上，在访问某条记录时，会按照下面的规则，从该记录的最新版本开始遍历，逐个判断某个版本是否可见 被访问版本的 trx_id 等于 creator_trx_id，表示当前事务在访问自己修改的记录，可见，返回 被访问版本的 trx_id 小于 min_trx_id，表明该版本在生成ReadView时，已经提交，可见，返回 被访问版本的 trx_id 大于 max_trx_id，表明该版本在生成ReadView时，还未开启，不可见，继续遍历 被访问版本的 trx_id 在 min_trx_id 和 max_trx_id 之间，那么则判断其是否在 m_ids 里面在则说明生成ReadView时该版本事务未提交，该版本不可见，反之则可见，返回 RC 与 RR 这俩隔离级别的一个不同就是：生成 ReadView 的时机不同RC 会在每一次普通 SELECT（快照读）前，都生成一个 ReadViewRR 只在第一次普通 SELECT（快照读）前，生成一个 ReadView，其作用于整个事务的生命过程因此，对于 RC 而言，由于每次查询前都生成新的 ReadView，这样读到的都是最新版本的 ReadView 下可见的数据所以，当在一个事务中出现其他事务对某一数据行操作，那么该事务中，两次读到结果就可能不一致所以才会说：RC 会引起不可重复读而对于 RR 来讲，由于只在第一次生成 ReadView，在事务的整个过程中都不会再生成了，而是重复使用 ReadView这样，即使在该事务中的两次读之间，做了其它的操作，那么第二次读时，仍然读到的是第一次读到的数据所以才会说：RR 解决了不可重复读undo log快照读，之所以能读到数据，就是因为数据的每个版本都被写在了 undo log 里面undo log 用于记录回滚日志（实现了数据的多版本），保证事务原子性，并且它一般是逻辑日志比如 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然而当 update 一条记录时，它会记录一条对应相反的 update 记录，这样回滚时就有迹可寻另外，undo log 也会产生 redo log，因为 undo log 也要实现持久性保护（redo log 是物理日志，会写入到文件中）它主要分两类： insert undo log：insert 时产生的，由于 insert 的记录只对当前事务可见，因此该 log 会在事务提交后直接删除 update undo log：update 和 delete 时产生的，由于需要实现快照读，故该 log 不能在事务提交时就进行删除redo log它实现了事务持久性，主要记录数据的修改, 用于异常恢复实际上是写入到文件中的它会记录写入位置与刷盘位置，循环写，循环刷，至于写的策略 / 刷盘的策略，它会有不一样的时机不一样的刷盘策略会有不一样的数据一致性保障，实际上就跟 MQ 一样，直接刷盘 / 定时刷盘 / 写完刷盘等等具体写入流程如下：这是 MySQL 执行一次数据更新的流程客户端发起一个 update 到 MySQL 服务端，服务端会有一个Server层（处理SQL解析等等各种设置）它会调用存储引擎的API，到达存储引擎这一层（这时一个 update 就会转化成存储引擎的操作命令，去修改数据）接下记录 undo log（即记录它的历史版本），再更新内存，再记 redo log（此时，更新的内存数据就和 redo log 匹配上了）然后告诉Server层说数据已经更新完毕，等待提交最后Server层提交事务，存储引擎层就会将事务记录为commit状态此时，内存里和 redo log 里面都有数据如果接下来内存里的数据丢了（比如重启了），redo log 还在，就可以根据 redo log 恢复数据，保证了数据的持久性锁机制按类型划分 共享锁：读锁，可以同时被多个事务获取，阻止其它事务对记录的修改 排它锁：写锁，只能被一个事务获取，允许获得锁的事务修改数据（所有当前读都是加的排它锁）按粒度划分 行级锁 间隙锁 表级锁行级锁行锁是作用在索引上的（即它是通过索引来锁住记录的，这样就不会造成写冲突） 针对聚簇索引，毫无疑问，就直接锁那条记录 针对二级索引，则会把二级索引自身及其回表后的主键索引都锁住（无论是 RC 还是 RR 隔离级别）如下图所示：（而对于非唯一索引，锁的东西会更多，详见下方间隙锁）间隙锁先说下幻读的场景：比如你在读到数据后，有人修改了这条数据，这时你再来操作这条数据，数据库就会告诉你失败了因为你在操作时，数据库实际的数据已经不是你手里读到的那个数据了而你的 “操作” 通常是 insert/update/delete 操作，这些操作又都是当前读，也就是拿数据库最新数据来操作所以你会失败，这就是幻读解决这个问题的办法也简单：只要让你没办法失败就行了，即只要让你没办法去 “操作” 这条数据，就行了InnoDB 的间隙锁（GAP Lock）正是这么做的：它保证了两次当前读之间，其它的事务不会插入新的满足条件的记录因此，其特点如下： 间隙锁解决了可重复读下的幻读问题 间隙锁能够保证两次当前读返回一致的记录 间隙锁不是加在记录上的，它锁的是两条记录之间的区间 严格来讲，是临键锁（Next-key Lock：是由 行锁 加 间隙锁 构成的）解决了幻读如上图所示，一共有 1、2、3 三个间隙也就是说，如果这三个间隙里面插入数据，那么可能就会影响到 delete 语句，所以就把这三个区间给锁住此时若插入 phone=132/133/134 的数据就会失败因此，间隙锁的开销还是比较大的（整个区间都不能往里面插入数据了） 而唯一索引之所以没有这个问题，是因为它本身已经保证唯一了，因此就不会有新的命中条件的数据了所以就只有在非唯一索引的情况下，才有这个问题表级锁它会锁整个表，一般 DBA 才会干这个事而在实际的业务开发中，也会有一种情况把整个表都锁住，如下图所示phone 字段没有建索引，然后删除它，这时就会发生全表扫描，所有记录都被锁住了实际过程就是引擎层把所有记录返回给Server层，Server层会去过滤，没命中的再释放掉而对于 RR 有间隙锁的情况，除了锁记录，额外还要去锁 GAP，这时的开销就非常大了，所以很耗性能死锁的分析先来看一下通常的加锁过程，如下图所示：Server层收到 update 指令，就会当前读到引擎层，这时可能会命中很多条记录引擎层就会一条一条的把记录加锁返回给Server层，Server层做更新后再返回给引擎层接着，引擎层再把下一条记录加锁返回给Server层，重复相同的过程，最终所有记录都加上锁都更新了，然后等待提交现在举个实际例子，来描述下死锁的产生，如下图所示：T1 根据 name 更新数据，T2 根据 age 做当前读（也可以是 update，主要强调的是当前读）而且 name 和 age 各自都有索引，当 T1 与 T2 并发执行时： 首先，T1 找到 uid=120 的主键记录，锁成功了 然后，T2 找到 uid=130 的主键记录，锁成功了 这个时候，T1 才找到 uid=130 的主键记录，也去锁，却发现被别的事务锁住了 紧接着呢，T2 又找到 uid=120 的主键记录，也去锁，也发现被别的事务锁住了 于是，T1 和 T2 互相等待对方释放锁，也就死锁了换句话说：两个语句并发执行时，对主键索引记录的加锁顺序不一样，就有可能会造成死锁" }, { "title": "研读MySQL01之存储原理与索引实现", "url": "/posts/mysql-page-index/", "categories": "中间件, 数据库", "tags": "MySQL", "date": "2022-01-21 11:33:00 +0800", "snippet": " 存储原理 数据页 插入策略 顺序保证 页内查询 索引实现 聚簇索引 二级索引 联合索引 最左匹配原则 索引区分度 覆盖索引 索引下推 外置索引 索引失效 存储原理数据页MySQL 从磁盘装载数据到内存时，是以页为单位的，一次装载一个或多个 Page下图就是 MySQL 内存里面一页数据的结构（一个页的大小固定为16KB） 页头：记录页面的控制信息，共 56 字节，包括相邻页面指针（页与页会组成一个双向链表）、页面空间使用情况等 虚记录：其本身不存储数据，它记录了这一页存储的数据的范围，这样就能知道某数据有没有落在这一页　　　　其中，最大虚记录比页内最大主键还大，最小虚记录比页内最小主键还小 记录堆：行记录存储区，分为有效记录和已删除记录 自由空间链表：已删除记录组成的链表，在写数据时会优先利用这部分空间，这样能够减少页面的空洞 未分配空间：页面未使用的存储空间 Slot区：在页内查找记录时用的，通过它能够做到近似二分查找，提高查询效率 页尾：页面的最后部分，是一个 8 个字节的校验位，主要存储页面的校验信息（能知道页面数据有没有发生错误）插入策略先尝试往页中的自由空间链表里面写当自由空间链表里面没有地方的时候，才会往未分配空间里面写这样就可以把页面的空洞最大化的利用起来顺序保证如上图所示，依次插入主键为 10、9、8 的数据假设通过物理连续来保证顺序（见上图的上半部分），那插入 9 时就得移动 10，插入 8 的时候就得移动 10 和 9但若通过逻辑连续来保证顺序（见上图的下半部分），那插入 9 时不用移动 10，在 9 上面用一个指针指向 10 即可由于频繁移动数据的性能开销是比较大的，所以 MySQL 采用的是逻辑连续来保证顺序也就是说，页内是单向链表，而页间则采用的是双向链表（每个页头都有指针指向相邻的页）如下图所示：页内查询上面提到，页内的数据是一个很长的单向链表，那么实际查询的时候，若直接遍历，通常效率比较低这里 MySQL 的查找方式就很像二分查找了 （注意：这里说的是页内的查找，页外的查找是靠的索引树）首先页的 Slot 区会通过对页内记录的统计，计算出若干槽位来每个槽位都会指向一条记录（是一条记录，不是一个区间的记录），通过这些槽位就能把页内的单向链表分成几段查找数据时，通过偏移的方式去做二分查找，最终会找到一个槽位，然后再去遍历该槽位对应的这一段链表，即可也就是说，MySQL 是借助 Slot 区实现了近似二分查找索引实现聚簇索引这是InnoDB聚簇索引的真实结构根节点指向它的叶子节点（可以认为是一个page，里面有很多索引数据），叶子节点之间双向链接最后的底层节点存的就是真正的主键 + Data，其页面之间也是双向链接下面换一张更形象一点的图：可以看到，聚簇索引的结构：通过树的方式，往下发散节点，最后到真正内存页：主键当key，Data存在它下面比如主键为 10 的数据的存储结构：左边指针指向的都是小于 10 的数据页，右边指向大于等于 10 小于 34 的数据页这就是聚簇的特点：数据与索引放在一起（找到索引也就找到了数据），且按照主键顺序存储（位于最底层的叶子节点）所以，选择主键的时候，很显然递增主键是最合适的（顺序写入，效率高）而随机主键，由于它的顺序可能忽大忽小，这会造成页内数据节点的分裂移动，使得写入性能下降，故不适合做主键因此，实际工作中，更多的会采用类似雪花算法来生成趋势递增的数字，作为业务主键，其即参与业务，又当作主键二级索引指的是除主键索引以外的索引（也可以叫非聚簇索引），其最底层叶子节点存储的是主键值（不是实际的数据）所以一次查询需要走两次索引，并且主键的大小会影响所有索引的大小（因为每一个非主键索引都会用到主键值）下面是二级索引的结构示意图：它跟聚簇不一样的地方是在 Data 域上：它的 Data 存的是主键的值当我们用非主键索引去查询的时候，比如要找索引值等于 5 的数据，实际找到的是主键值，而非真正的数据然后再拿主键值，回到主键索引（聚簇索引）上去找，最后找到了这条数据而这个过程，也称为回表查询联合索引一个联合索引只创建一棵树，它由多个字段组成，排序时先按第一列排序，第一列相同就按第二列排（依此类推）下面是它的结构示意图：其实联合索引就是从一个 key 变成多个 key，然后再定义一个比较的规则，这样就构成了联合索引也就是把索引的 “多个字段” 都放到索引 key 里面，比较的时候，就比较最左前缀（先比较第一列，再比较后面的列）可以看到，联合索引还是一个二级索引，它最终拿到的还是主键值，还是要回表才能查到真正的数据最左匹配原则实际在查询时，它也是遵循最左匹配原则的，以联合索引顺序 (a,b,c) 为例，下面是几个常见场景： 如果不是按照最左开始查找，则无法使用索引b=xx AND c=xx：由于排序比较时，是先按 a 条件比较的，现在没有 a 条件，所以就没办法命中索引了 不能跳过中间列a=xx AND c=xx：能用上一部分索引，因为通过 a 能够查到一个范围，然后回表拿到实际数据后，再根据 c 筛选 某列使用范围查询，后面的列不能使用索引a≥xx AND b=xx：先通过 a 查到一个范围的记录，接着 b 就用不了索引了，因为 a 范围内，b 数据几乎是无序的a=xx AND b≥xx AND c=xx：这时可以用到 a 和 b，但用不到 c，因为 b 是一个范围索引区分度创建联合索引时，通常会把索引区分度高（即全局唯一或者像时间这种能够区分出一个范围的）的字段放在前面而如果把区分度过低的（比如性别、年龄）放在前面比如性别，那么查询时，正常来讲会先找到一半数量的主键值，然后再逐个回表查询，最后返回结果而实际上这种情况下 mysql 会认为它区分度太低了，使得查询效率很低，因此 mysql 会自动走全表扫描覆盖索引比如一张表，有三个字段：主键、uid、phone，现在想通过 uid 来查 phone正常的，会对 uid 建一个索引，由于是二级索引，所以会走回表查询，最后查到 phone实际上，如果这种查询很多的话，那么就可以利用联合索引的覆盖索引的特性，拿 uid 和 phone 来建一个联合索引查询时，通过 uid 就会找到联合索引的 key 以及它的主键值，但是由于 key 里面已经包含了我要找的 phone那这时，mysql 就不会再回表了，直接就会返回 phone（避免了回表）索引下推mysql 服务端有一个 Server 层，在 Server 层下面还有一个 InnoDB 存储引擎层下面以查询条件 WHERE a=xx AND b≥xx 为例如果只对 a 建一个二级索引，那么查询时，引擎层会将回表后得到的一批数据，返回给 Server 层Server 层再根据 b 过滤，最后得到最终结果而索引下推则是：根据 b 来过滤的动作，也交给引擎层来做具体做法就是拿 a 和 b 建一个联合索引，由于联合索引具有索引下推的特性，所以 b 条件也会通过 Server 层传给引擎层引擎层在根据 a 回表得到一批数据后，就会拿 b 来过滤，然后返回给 Server 层由于是在引擎层直接就处理了，所以效率就变高了 由于联合索引具有的这些特性，所以，实际中，联合索引的使用，要优于多列独立索引还有一点，其实联合索引也间接的满足了查询和排序外置索引比如根据商品信息或商品描述里面的某个词来查询这时就不能用数据库的模糊查询了，效率太低，可以借助 Elasticsearch 这类工具来建一个外置索引说白了就是：发布完商品，就把商品描述信息同步到 ES，ES 自动建立一个根据关键字到商品 ID 的索引拿关键字查询的时候，就先到 ES 查一下都命中了哪些商品 ID，然后再返回商品索引失效 索引区分度过低或者条件超出索引范围比如时间戳字段做索引，查询条件是 ts&amp;gt;0，这时就会全表扫描，因为条件超出范围了 a=xx OR b=xx结论：这种场景下，a 与 b 都要建索引分析：如果 a 建了索引，b 没有索引，那么 a 走完索引查到数据后　　　发现后面还有 OR 的条件，就还要根据 b 来查一遍，但是 b 又没有索引，这时就会全表扫描注意：如果 a 和 b 都建了索引，那就意味着这是两棵树，而一次查询怎么能走两棵树呢？　　　为了解决这个问题，MySQL-5.1开始，引入了 Index Merge 技术，支持对同一个表使用多个索引分别扫描　　　最后对两棵树的查询结果取并集（如果是 AND 查询条件，就取交集） 隐式类型转换比如数据库手机号，是 char(11) 类型的，实际传入的参数是整型的，这时就会发现类型不匹配，就走全表扫描了 索引列包含计算比如查询条件为 WHERE name-20=30，解决办法就是 WHERE name=50（把 20 挪到后面，规避掉计算步骤）" }, { "title": "研习RocketMQ03之事务消息与延时消息", "url": "/posts/rocketmq-tx-delay/", "categories": "中间件, 消息队列", "tags": "RocketMQ", "date": "2022-01-03 11:33:00 +0800", "snippet": " 事务消息 实现流程 核心原理 缺点 自定义实现 延时消息 缺点 事务消息实现流程上图为 RocketMQ 事务消息实现流程，也是基于两阶段提交协议（2PC） HALF消息MQ 收到一条事务消息后：会将该事务消息的主题和队列信息，转换成，半消息储存起来然后放到RMQ_SYS_TRANS_HALF_TOPIC里面，而该topic对consumer是不可见的，所以半消息不会被订阅和消费 OP消息MQ收到针对事务消息的commit或rollback时，会将其储存在RMQ_SYS_TRANS_OP_HALF_TOPIC里面然后，若是rollback，则只做记录；若是commit，则根据HALF消息还原事务消息内容并投递出去（投递到commitlog） 回查针对超过一定时间的HALF消息，且OP消息还没到，则会回查生产者拿到事务结果（回查时间间隔与次数均可配）核心原理结合上面这张图，大致描述一下核心原理：生产者发送一条事务消息，MQ 收到后，也会写到CommitLog，然后dispatch线程发现这是一个事务消息那就不会把它放到ConsumerQueue，会把它放到 half topic 的队列里面，这样它就不会被消费掉接着本地事务处理完，就会发 commit/rollback 到 MQ，然后就会被放到 op topic 的队列里面如果过来的是 rollback，那就不用做什么处理，只记录下来就行如果过来的是 commit，那就根据 half topic 队列里面备份的信息，还原事务消息并重新投递到CommitLog这样dispatch就可以把它放到该放的ConsumerQueue里面，然后就能够被消费到了缺点需要业务方提供回查接口，对业务有侵入（可能个别业务场景都不支持回查，或者处理起来很复杂）自定义实现在了解了基本原理后，也可以自己实现一套事务消息组件，如上图举例大致思路就是通过客户端来实现，好处是不管 MQ Server 使用哪一款 MQ 产品，这个组件都能实现事务消息同时，把消息发送事件记录在事务消息表 Msg Table，通过本地事务来保证业务数据与写消息表的原子性然后，程序里再写一个事务消息管理器来维护 Msg Table（扫库发送&amp;amp;清理等）在封装组件时，除了处理发送失败及重试的特殊情况，还要尽量让业务感知不到里面的细节让业务认为就是在用一个新的 MQ 客户端，或者说调用了一个新的 API它就是在发出一条事务消息，并且这个消息能自己保证原子性，业务也不用实现回查接口，减轻业务的负担延时消息RocketMQ 支持 18 个级别的延时等级，默认值为：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h生产者发消息时通过设置delayLevel选择它的实现原理跟事务消息很像：实际RocketMQ很多功能都是类似方案，比如消息失败的重试，可以说是一通百通具体实现是这样的：MQ 收到延迟消息时，就会把它替换为 SCHEDULE_TOPIC_XXX 主题（也就是不进行投递）在 SCHEDULE_TOPIC_XXX 主题中有 18 个队列，分别对应 18 个延时级别接着就是根据延迟级别把消息放入对应的延时队列里面，而每个队列都有定时任务进行调度这样就可以恢复到期消息，重新投递到真实的Topic，写到commitlog，进而真正的发送出去供消费缺点不支持任意时间延时如果想延迟 15s 怎么办它一共只支持18个级别，那就把其中一个级别的时间改成15s，也就是改一下rocketmq配置，再重启就行了那另一个业务侧希望延迟 45s 呢，最后 18 个级别都不够用了怎么办那就得加集群了，可这样做太麻烦了所以网上才会有不少人基于时间轮算法对它进行定制" }, { "title": "研习RocketMQ02之生产消费与负载均衡", "url": "/posts/rocketmq-data-ha/", "categories": "中间件, 消息队列", "tags": "RocketMQ", "date": "2022-01-02 11:33:00 +0800", "snippet": " 生产与消费 生产方式 消费方式 集群消费 负载均衡 Producer端负载均衡 Consumer端负载均衡 生产与消费生产方式producer有三种生产消息的方式 同步（sync）：消息投递出去之后，broker同步返回成功或失败 异步（async）：消息投递出去之后，不用等结果，自己写一个callback来接收投递结果 单向（oneway）：就是啥也不管，无脑投递这里实际是要结合broker的刷盘方式，来看用哪种生产方式（多方配合）消费方式消费方式一般分为推和拉两种 PUSH：消息队列主动将消息推给消费者（优点是消息实时性高，缺点是忽略了客户端的消费能力） PULL：消费者主动向消息队列拉取消息（缺点是消息实时性低，可能造成大量无效请求）RocketMQ的消费方式介于推和拉之间，它使用了一种长轮询机制，来平衡推拉各自的缺点 Consumer发送拉取消息请求 Broker hold 住请求，直到有新消息再返回 请求超时（超时时间默认30s），Consumer再次发起请求这样保证了实时性（一直有一个连接在），也没有过多的无效请求（30s才超时，没有数据时，一分钟才发俩请求）而且客户端收到请求的回复之后，如果处理不过来，可以等数据处理完，再发起下一次拉取请求，不用立即发起所以它是按照客户端的处理能力去尽量实时的拉取消息，兼顾了性能和实时时性集群消费 集群内部：单条消息只会被消费一次，且各节点会均匀消费topic消息 多个集群：则各集群消费全量的消息，且单条消息在每个集群也只会被消费一次也就是说，集群消费的模式，它要求一个队列只能被一个消费者消费（但一个消费者可以消费多个队列）因为一个队列如果被多个消费者消费，那消费的offset该怎么移动，就是件麻烦事儿比如有User集群和Order集群，都去消费同一个topic消息那么单条消息既会被User集群消费到，也会被Order集群消费到且在每个集群内都只会被消费一次（具体被集群里的哪个节点消费，则由负载均衡决定）并且这俩集群都会消费到该topic的全量消息（各自集群内部根据节点数量均匀的消费）可以把User集群和Order集群理解成两个group，即：组内竞争消费，组间广播消费负载均衡RocketMQ 中的负载均衡都是在 Client 端完成的Producer端负载均衡生产者端会定时获取到主题的队列信息，这样知道了topic在哪几个broker上都有哪些queue于是，投递消息时，就可以通过本地算法，指定这个消息分发到具体broker上的具体queue上去默认的负载均衡算法是采用随机递增取模（生成一个随机数，然后按队列数取模）的方式并且producer端的容错机制是以故障延迟的方式实现的即：当若某队列出问题导致发消息失败，那么再次取模到该队列时，会跳过并为其设置一个 N 毫秒的失效时间等到下次再碰到该队列时，如果失效时间还没到，就继续跳过，要是时间到了就看还能不能往上面发消息能发消息就用它，不能发消息就再为其置一个失效时间（比上一次的失效时间还要长一些）Consumer端负载均衡由于客户端本身并不知道彼此的存在，所以客户端独自很难实现均衡消费而RocketMQ是通过Rebalance机制来实现的Consumer端负载均衡它可以从broker收集到客户端数据（客户端会上报心跳），再加上定时触发的Rebalance（大概20s一次）consumer就会得到同一个topic的所有队列信息和所有订阅了的消费者信息再根据consumer的数量和队列数量，来平均分配（有点类似分页，你分几个，我分几个，大家平均着来）最后，分配完，再和本地结果（也就是上一次结果）做一次对比如果，上一次结果中分配的某个队列不在本次分配的队列列表里，那就剔除该队列最终，就是要保证一个队列只会被一个消费者使用，不会出现一个队列被两个人消费的情况不过，当consumer节点数超过topic队列的数量时，则必然会有至少一个节点分配不到队列而处于空闲注意：每个队列的长度均匀，消息量均匀，这是由生产者做的" }, { "title": "springboot整合liquibase（强烈推荐）", "url": "/posts/liquibase%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/", "categories": "springboot, liquibase", "tags": "liquibase, 数据库版本管理", "date": "2020-08-07 12:10:00 +0800", "snippet": "Liquibase是一个开源数据库模式更改管理解决方案，它使您能够轻松管理数据库更改的修订。Liquibase使参与应用程序发布过程的任何人都可以轻松地： 消除发布数据库时的错误和延迟。 部署和回滚特定版本的更改，而无需知道已部署的内容。 将数据库和应用程序更改一起部署，以便它们始终保持同步。ps:本人最直观的感觉就是在部署不同环境的时候不用再手动执行初始化sql脚本;springboot集成引入liquibase依赖（以Maven为例） &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.liquibase&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;liquibase-core&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.3.5&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;配置liquibase 在application.yml加入以下内容：spring: liquibase: enabled: true change-log: &quot;classpath:/db/master.xml&quot; contexts: ${spring.profiles.active} url: ${spring.datasource.url} user: ${spring.datasource.username} password: ${spring.datasource.password}contexts：liqubase启动的环境，这里设置为与spring启动环境保持一致change-log：加载主（入口）变更文件位置，这里是resources/db/master.xml配置主变更文件master.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;databaseChangeLog xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd&quot;&amp;gt; &amp;lt;!-- 引入xml格式的变更文件 --&amp;gt; &amp;lt;include file=&quot;classpath:/liquibase/xml/01-create-test-schema.xml&quot; relativeToChangelogFile=&quot;false&quot;&amp;gt;&amp;lt;/include&amp;gt;&amp;lt;!-- &amp;lt;include file=&quot;classpath:/liquibase/xml/02-insert-test-data.xml&quot; relativeToChangelogFile=&quot;false&quot;&amp;gt;&amp;lt;/include&amp;gt;--&amp;gt; &amp;lt;!-- 引入sql格式的变更文件 --&amp;gt; &amp;lt;include file=&quot;liquibase/sql/test.sql&quot;/&amp;gt;&amp;lt;!-- &amp;lt;include file=&quot;liquibase/sql/add2.sql&quot;/&amp;gt;--&amp;gt; &amp;lt;!-- includeAll：表示sql文件夹下面的所有文件都被liquibase管理--&amp;gt;&amp;lt;!-- &amp;lt;includeAll path=&quot;/sql/&quot; relativeToChangelogFile=&quot;true&quot;/&amp;gt;--&amp;gt;&amp;lt;/databaseChangeLog&amp;gt;编辑子变更文件（实际sql变更内容）,子变更文件格式支持xml与sqlxml格式编写01-create-test-schema.xml （xml格式：优点屏蔽不同数据库sql语言差异；缺点是需要一定的学习成本）&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;databaseChangeLog xmlns=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd&quot;&amp;gt; &amp;lt;changeSet id=&quot;01&quot; author=&quot;classmaster&quot;&amp;gt; &amp;lt;createTable tableName=&quot;classmaster&quot;&amp;gt; &amp;lt;column name=&quot;id&quot; type=&quot;int&quot;&amp;gt; &amp;lt;constraints primaryKey=&quot;true&quot; nullable=&quot;false&quot;/&amp;gt; &amp;lt;/column&amp;gt; &amp;lt;column name=&quot;name&quot; type=&quot;varchar(50)&quot;&amp;gt; &amp;lt;constraints nullable=&quot;false&quot;/&amp;gt; &amp;lt;/column&amp;gt; &amp;lt;column name=&quot;active&quot; type=&quot;boolean&quot; defaultValueBoolean=&quot;true&quot;/&amp;gt; &amp;lt;/createTable&amp;gt; &amp;lt;/changeSet&amp;gt;&amp;lt;/databaseChangeLog&amp;gt;xml语法这里不做介绍，详细可以阅读官方文档sql格式编写test.sql （sql格式：优点简单处理即可支持liquibase）--liquibase formatted sql--changeset leoz:1ALTER TABLE DATABASECHANGELOG ADD PRIMARY KEY (ID);CREATE TABLE IF NOT EXISTS `test`( `id` INT UNSIGNED AUTO_INCREMENT, `name` VARCHAR(100) NOT NULL, `author` VARCHAR(40) NOT NULL, `date` DATE, PRIMARY KEY ( `id` ));--changeset leoz:2INSERT INTO `test` (`id`, `name`, `author`, `date`) VALUES (&#39;2&#39;, &#39;test&#39;, &#39;admin&#39;, &#39;2021-10-14&#39;);INSERT INTO `test` (`id`, `name`, `author`, `date`) VALUES (&#39;3&#39;, &#39;test&#39;, &#39;admin&#39;, &#39;2021-10-14&#39;);INSERT INTO `test` (`id`, `name`, `author`, `date`) VALUES (&#39;4&#39;, &#39;test&#39;, &#39;admin&#39;, &#39;2021-10-14&#39;);这里springboot整合liquibase完成，启动项目看看效果把；项目启动后liquibase会在数据库中添加一个日志表和一个锁表用于版本控制；注意 sql文件第一行必须是--liquibase formatted sql --changeset leoz:1 --changeset代表一次变更 leoz:1 指（作者：版本） 一个sql文件可以写多个变更，一个变更内容一旦执行不可修改；（一次 --changeset 中的内容代表一个变更）test.sql中就有两次变更；常见错误 初始化的时候 如果日志报错DATABASECHANGELOG没有主键错误则应该把这条ALTER TABLE DATABASECHANGELOG ADD PRIMARY KEY (ID);sql语句加上，否则不用加 如果自定义配置了数据源有可能出现其他对象访问数据库在liquibase初始化之前，导致出现xxx表不存在错误；这种情况的解决方案可以在依赖数据库的对象上面添加@DependsOn(&quot;liquibase&quot;)注解;例如在对ruoyi框架改造时出现了这种问题，解决代码如下 @DependsOn(&quot;liquibase&quot;)@Servicepublic class SysConfigServiceImpl implements ISysConfigService{} 本文简单介绍了liquibase的基本使用方式，如需了解更多知识请移步liquibase官方文档 " }, { "title": "SpringCloud系列-09之消息总线Bus", "url": "/posts/springcloud-bus/", "categories": "SpringCloud", "tags": "SpringCloud", "date": "2020-04-19 12:10:00 +0800", "snippet": " RabbitMQ的安装 RabbitMQ的管理 示例代码 注册中心 配置中心 服务提供方 验证上一节的统一配置中心《SpringCloud系列第08节之配置中心Config》演示了属性热加载其中提到，每次热加载属性时，都要逐次调用每个应用的 /refresh 接口（或者维护 Git 仓库的 Webhooks）来触发属性更新随着系统的扩充，应用的增加，若所有的触发动作都要手工去做（或者维护 Git 仓库的 Webhooks），这是不人道的所以我们希望配置中心的属性发生变化时，能有一种途径去通知所有的相关应用去自动刷新配置而通过 Spring Cloud Bus 就能够实现以消息总线的方式，通知集群上的应用，去动态更新配置信息本文是以 RabbitMQ 来作为消息代理的中间件（实现将消息路由到一个或多个目的地），所以要先安装 RabbitMQRabbitMQ的安装RabbitMQ 是 AMQP（Advanced Message Queuing Protocol）协议的一个开源实现的产品它是由以高性能、健壮、可伸缩性出名的 Erlang OTP 平台实现的工业级的消息队列服务器所以在安装 RabbitMQ 之前，要先安装 Erlang，下面是它们的下载地址http://erlang.org/download/otp_win64_19.3.exehttp://www.rabbitmq.com/releases/rabbitmq-server/v3.6.9/rabbitmq-server-3.6.9.exeWindows 下安装成功后，RabbitMQ Server 会自动注册为服务，并以默认配置启动也可以在开始菜单，找到 RabbitMQ Server 目录，点击 RabbitMQ Service - start 来启动RabbitMQ的管理为了能在 Web 界面管理 RabbitMQ，我们还需要启用它的管理插件D:\\Develop\\RabbitMQServer\\rabbitmq_server-3.6.9\\sbin&amp;gt;rabbitmq-plugins enable rabbitmq_managementThe following plugins have been enabled: amqp_client cowlib cowboy rabbitmq_web_dispatch rabbitmq_management_agent rabbitmq_managementApplying plugin configuration to rabbit@Jadyer-PC... started 6 plugins.D:\\Develop\\RabbitMQServer\\rabbitmq_server-3.6.9\\sbin&amp;gt;启用后，浏览器访问 http://127.0.0.1:15672/ 即可（登录的用户名密码均为 guest）登录进去之后，可以在上方的 Admin 导航菜单中新建用户，并分配权限等等示例代码示例代码如下（也可以直接从 Github 下载：https://github.com/v5java/demo-cloud-09-bus）它是由四个模块组成的 Maven 工程，包含了一个注册中心、一个配置中心、两个读取了配置中心属性的服务提供方它是在上一节的统一配置中心《SpringCloud系列第08节之配置中心Config》的代码基础上改的由于改动不多，所以下面就只列出来各个改动点注册中心无修改配置中心 引入依赖项spring-cloud-starter-bus-amqp application.yml 中添加 spring.rabbitmq.* 的配置，如下所示spring: rabbitmq: host: 127.0.0.1 port: 5672 # 注意端口是5672，不是15672 username: xuanyu password: xuanyu服务提供方其改动部分与配置中心相同：都是引入依赖，添加 rabbitmq 配置，简单粗暴一步到位（Spring Cloud Bus 自动化配置的功劳）验证还是分别访问两个服务提供方暴露出来的接口http://127.0.0.1:2100/demo/config/getHosthttp://127.0.0.1:2200/demo/config/getHost属性热加载时，需要调用消息总线的 /bus/refresh 接口，共有两种方式（都能使集群中其它节点动态刷新读取到的属性） 调用某个应用的接口：curl -X POST http://127.0.0.1:2100/bus/refresh 调用消息总线的接口：curl -X POST http://127.0.0.1:4100/bus/refresh但在需要迁移某个使用了的节点时，就不得不修改 Git 仓库的 Webhooks所以，为了使得各个微服务保持对等，故推荐第二种方式来刷新属性另外，也可通过 destination 参数来指定刷新范围，举例如下curl -X POST http://127.0.0.1:4100/bus/refresh?destination=demo.cloud.config:2200curl -X POST http://127.0.0.1:4100/bus/refresh?destination=demo.cloud.config:**" }, { "title": "SpringCloud系列-08之配置中心Config", "url": "/posts/springcloud-config/", "categories": "SpringCloud", "tags": "SpringCloud", "date": "2020-04-17 12:10:00 +0800", "snippet": " 统一配置中心 一些规则 yml的加载顺序 url的映射关系 属性的热加载 示例代码 注册中心 配置中心 服务提供方01 服务提供方02 验证 彩蛋统一配置中心微服务架构中，每个微服务的运行，都会读取不同环境的不同配置信息而Spring Cloud Config（百度的 Disconf 与之类似）便提供了适用于分布式系统的、集中式的外部化配置支持它能够统一集中管理所有应用的、所有环境的配置文件，且支持热更新其默认采用 git 仓库存储配置信息，好处是 git 工具便可轻松管理配置内容（虽然也支持 svn 仓库存储和本地存储，但相信，很少有人这么做）更多内容，可参考：http://cloud.spring.io/spring-cloud-static/Camden.SR4/#_spring_cloud_config关于配置仓库里面文件内容的加密，可考虑：http://cloud.spring.io/spring-cloud-vault/关于配置中心的高可用，可参考：https://github.com/spring-cloud/spring-cloud-config/issues/87关于配置中心与注册中心联合使用，可参考：https://github.com/spring-cloud/spring-cloud-config/blob/master/docs/src/main/asciidoc/spring-cloud-config.adoc#discovery-first-bootstrap一些规则yml的加载顺序应用读取配置中心参数时，会配置配置中心的地址等相关参数，而这部分配置需优先于 application.yml 被应用读取SpringCloud 中的 bootstrap.yml 是会比 application.yml 先加载的，所以这部分配置要定义在 bootstrap.yml 里面这就引申出两个需要注意的地方 spring.application.name它应该配置在 bootstrap.yml，它的名字应该等于配置中心的配置文件的 {application}所以配置中心在给配置文件取名字时，最好让它等于对应的应用服务名 配置中心与注册中心联合使用若应用通过 serviceId 而非 url 来指定配置中心，则 eureka.client.serviceUrl.defaultZone 也要配置在 bootstrap.yml要不启动的时候，应用会找不到注册中心，自然也就找不到配置中心了 url的映射关系/{application}/{profile}[/{label}]/{application}-{profile}.yml/{label}/{application}-{profile}.yml/{application}-{profile}.properties/{label}/{application}-{profile}.properties其中，{label} 对应 git 分支，{application}-{profile}.properties 对应配置文件的名字所以，可以根据不同的 url 来访问不同的配置内容，比如本文的示例就对应下面链接http://127.0.0.1:4100/demo.cloud.config/dev/masterhttp://127.0.0.1:4100/demo.cloud.config-dev.ymlhttp://127.0.0.1:4100/master/demo.cloud.config-test.ymlhttp://127.0.0.1:4100/demo.cloud.config-prod.propertieshttp://127.0.0.1:4100/master/demo.cloud.config-dev.properties属性的热加载1、显式标注 @RefreshScope2、添加依赖 spring-boot-starter-actuator3、刷新属性 curl -X POST http://127.0.0.1:2100/refresh（大写的 X 和 POST）示例代码示例代码如下（也可以直接从 Github 下载：https://github.com/v5java/demo-cloud-08-config）它是由四个模块组成的 Maven 工程，包含了一个注册中心、一个配置中心、两个读取了配置中心属性的服务提供方这是公共的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-08-config&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;service-config&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-discovery&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-server&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Camden.SR6&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt;注册中心这是注册中心的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-08-config&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是注册中心的配置文件 /src/main/resources/application.ymlserver: port: 1100eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 续期时间，即扫描失效服务的间隔时间（缺省为60*1000ms） client: # 设置是否从注册中心获取注册信息（缺省true） # 因为这是一个单点的EurekaServer，不需要同步其它EurekaServer节点的数据，故设为false fetch-registry: false # 设置是否将自己作为客户端注册到注册中心（缺省true） # 这里为不需要（查看@EnableEurekaServer注解的源码，会发现它间接用到了@EnableDiscoveryClient） register-with-eureka: false # 在未设置defaultZone的情况下，注册中心在本例中的默认地址就是http://127.0.0.1:1100/eureka/ # 但奇怪的是，启动注册中心时，控制台还是会打印这个地址的节点：http://localhost:8761/eureka/ # 而实际服务端注册时，要使用1100端口的才能注册成功，8761端口的会注册失败并报告异常 serviceUrl: # 实际测试：若修改尾部的eureka为其它的，比如/myeureka，注册中心启动没问题，但服务端在注册时会失败 # 报告异常：com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server defaultZone: http://127.0.0.1:${server.port}/eureka/这是注册中心的 SpringBoot 启动类 ServiceDiscoveryBootStrap.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;//创建服务注册中心@EnableEurekaServer@SpringBootApplicationpublic class ServiceDiscoveryBootStrap { public static void main(String[] args) { SpringApplication.run(ServiceDiscoveryBootStrap.class, args); }}配置中心这是配置中心的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-08-config&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-config&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是配置中心的配置文件 /src/main/resources/application.ymlserver: port: 4100spring: application: name: jadyer-config-server cloud: config: server: git: uri: https://github.com/v5java/demo-cloud-08-config # 配置git仓库的地址 searchPaths: config-repo # git仓库下的相对地址（多个则用半角逗号分隔） # username: username # 只有private的项目才需配置用户名和密码 # password: password # 只有private的项目才需配置用户名和密码eureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15 client: healthcheck: enabled: true serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/这是配置中心的 SpringBoot 启动类 ServiceConfigBootStarp.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;//开启配置中心@EnableConfigServer@EnableEurekaClient@SpringBootApplicationpublic class ServiceConfigBootStarp { public static void main(String[] args) { SpringApplication.run(ServiceConfigBootStarp.class, args); }}服务提供方01这是第一个服务提供方的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-08-config&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-server&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是第一个服务提供方的配置文件 /src/main/resources/application.ymlserver: port: 2100#spring:# application:# name: CalculatorServer # 指定发布的微服务名（以后调用时，只需该名称即可访问该服务）eureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true # 设置微服务调用地址为IP优先（缺省为false） lease-renewal-interval-in-seconds: 5 # 心跳时间，即服务续约间隔时间（缺省为30s） lease-expiration-duration-in-seconds: 15 # 发呆时间，即服务续约到期时间（缺省为90s） client: healthcheck: enabled: true # 开启健康检查（依赖spring-boot-starter-actuator） #serviceUrl: # defaultZone: http://127.0.0.1:1100/eureka/ # 指定服务注册中心的地址这是第一个服务提供方的配置文件 /src/main/resources/bootstrap.yml 注：实际使用时，spring.cloud.config.profile 不需配置，它会自动读取 spring.profiles.active 的值spring: application: name: demo.cloud.config # 指定配置中心配置文件的{application} cloud: config: #uri: http://127.0.0.1:4100/ # 指定配置中心的地址 profile: prod # 指定配置中心配置文件的{profile} label: master # 指定配置中心配置文件的{label} discovery: enabled: true # 使用注册中心里面已注册的配置中心 serviceId: jadyer-config-server # 指定配置中心注册到注册中心的serviceIdeureka: client: serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/这是第一个服务提供方的 SpringBoot 启动类 ServiceServerBootStarp.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * 通过 @EnableEurekaClient 注解，为服务提供方赋予注册和发现服务的能力 * -------------------------------------------------------------------------------------------- * 也可以使用org.springframework.cloud.client.discovery.@EnableDiscoveryClient注解 * 详见以下两篇文章的介绍 * http://cloud.spring.io/spring-cloud-static/Camden.SR3/#_registering_with_eureka * https://spring.io/blog/2015/01/20/microservice-registration-and-discovery-with-spring-cloud-and-netflix-s-eureka * -------------------------------------------------------------------------------------------- * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/9 16:00. */@EnableEurekaClient@SpringBootApplicationpublic class ServiceServerBootStarp { public static void main(String[] args) { SpringApplication.run(ServiceServerBootStarp.class, args); }}这是第一个服务提供方读取配置中心参数（且支持热加载）的例子 DemoController.javapackage com.jadyer.demo;import org.springframework.beans.factory.annotation.Value;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;//支持配置中心属性热加载@RefreshScope@RestController@RequestMapping(&quot;/demo/config&quot;)public class DemoController { //获取配置中心的属性 @Value(&quot;${host.ifs}&quot;) private String ifsHost; @GetMapping(&quot;/getHost&quot;) public String getHost(){ return this.ifsHost; }}服务提供方02除了启动端口为2200外，其代码与服务提供方01的完全相同验证分别访问两个服务提供方暴露出来的接口http://127.0.0.1:2100/demo/config/getHosthttp://127.0.0.1:2200/demo/config/getHost然后再 curl -X POST http://127.0.0.1:2100/refresh 后发现只有2100端口的服务属性刷新了，2200的没变所以才有了下面的彩蛋彩蛋属性热加载前，都要手工调用各个应用的刷新接口，即便使用 Git 仓库的 Webhooks，维护起来也够费劲的解决办法也有，详见下一篇文章《SpringCloud系列第09节之消息总线Bus》中通过消息总线的方式，实现集群的自动更新" }, { "title": "SpringCloud系列-07之服务网关Zuul", "url": "/posts/springcloud-zuul/", "categories": "SpringCloud", "tags": "SpringCloud", "date": "2020-04-15 12:10:00 +0800", "snippet": " 为什么需要网关 网关映射 示例代码 注册中心 服务提供方01 服务提供方02 服务网关01 服务网关02 服务消费方 验证为什么需要网关之前的系列文章中演示了，服务提供方和消费方都注册到注册中心，使得消费方能够直接通过 ServiceId 访问服务方实际情况是：通常我们的服务方可能都需要做 接口权限校验、限流、软负载均衡 等等而这类工作，完全可以交给服务方的更上一层：服务网关，来集中处理这样的目的：保证微服务的无状态性，使其更专注于业务处理所以说，服务网关是微服务架构中一个很重要的节点，Spring Cloud Netflix 中的 Zuul 就担任了这样的角色当然了，除了 Zuul 之外，还有很多软件也可以作为 API Gateway 的实现，比如 Nginx Plus、Kong 等等网关映射通过服务路由的功能，可以在对外提供服务时，只暴露 Zuul 中配置的调用地址，而调用方就不需要了解后端具体的微服务主机Zuul 提供了两种映射方式：URL 映射和 ServiceId 映射（后者需要将 Zuul 注册到注册中心，使之能够发现后端的微服务）ServiceId 映射的好处是：它支持软负载均衡，基于 URL 的方式是不支持的（实际测试也的确如此）示例代码示例代码如下（也可以直接从 Github 下载：https://github.com/v5java/demo-cloud-07-zuul）它是由六个模块组成的 Maven 工程，其中包含兩个服务提供方、两个服务网关、一个注册中心、一个服务消费方它们的关系是：消费方走软负载均衡调用两个服务网关，服务网关根据路由配置，再一次走软负载均衡调用两个服务提供方这是公共的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-07-zuul&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;service-client&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-discovery&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-gateway-01&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-gateway-02&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-server-01&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-server-02&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Camden.SR6&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt;注册中心这是注册中心的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-07-zuul&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是注册中心的配置文件 /src/main/resources/application.ymlserver: port: 1100eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 续期时间，即扫描失效服务的间隔时间（缺省为60*1000ms） client: # 设置是否从注册中心获取注册信息（缺省true） # 因为这是一个单点的EurekaServer，不需要同步其它EurekaServer节点的数据，故设为false fetch-registry: false # 设置是否将自己作为客户端注册到注册中心（缺省true） # 这里为不需要（查看@EnableEurekaServer注解的源码，会发现它间接用到了@EnableDiscoveryClient） register-with-eureka: false # 在未设置defaultZone的情况下，注册中心在本例中的默认地址就是http://127.0.0.1:1100/eureka/ # 但奇怪的是，启动注册中心时，控制台还是会打印这个地址的节点：http://localhost:8761/eureka/ # 而实际服务端注册时，要使用1100端口的才能注册成功，8761端口的会注册失败并报告异常 serviceUrl: # 实际测试：若修改尾部的eureka为其它的，比如/myeureka，注册中心启动没问题，但服务端在注册时会失败 # 报告异常：com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server defaultZone: http://127.0.0.1:${server.port}/eureka/这是注册中心的 SpringBoot 启动类 ServiceDiscoveryBootStrap.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;//创建服务注册中心@EnableEurekaServer@SpringBootApplicationpublic class ServiceDiscoveryBootStrap { public static void main(String[] args) { SpringApplication.run(ServiceDiscoveryBootStrap.class, args); }}服务提供方01这是第一个服务提供方的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-07-zuul&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-server-01&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是第一个服务提供方的配置文件 /src/main/resources/application.ymlserver: port: 2100spring: application: name: CalculatorServer # 指定发布的微服务名（以后调用时，只需该名称即可访问该服务）eureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true # 设置微服务调用地址为IP优先（缺省为false） lease-renewal-interval-in-seconds: 5 # 心跳时间，即服务续约间隔时间（缺省为30s） lease-expiration-duration-in-seconds: 15 # 发呆时间，即服务续约到期时间（缺省为90s） client: healthcheck: enabled: true # 开启健康检查（依赖spring-boot-starter-actuator） serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/ # 指定服务注册中心的地址这是第一个服务提供方的 SpringBoot 启动类 ServiceServer01BootStarp.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * 通过 @EnableEurekaClient 注解，为服务提供方赋予注册和发现服务的能力 * -------------------------------------------------------------------------------------------- * 也可以使用org.springframework.cloud.client.discovery.@EnableDiscoveryClient注解 * 详见以下两篇文章的介绍 * http://cloud.spring.io/spring-cloud-static/Camden.SR3/#_registering_with_eureka * https://spring.io/blog/2015/01/20/microservice-registration-and-discovery-with-spring-cloud-and-netflix-s-eureka * -------------------------------------------------------------------------------------------- * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/9 16:00. */@EnableEurekaClient@SpringBootApplicationpublic class ServiceServer01BootStarp { public static void main(String[] args) { SpringApplication.run(ServiceServer01BootStarp.class, args); }}这是第一个服务提供方暴露的数学运算服务 CalculatorController.javapackage com.jadyer.demo;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * 服务提供方暴露的数学运算服务 * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/9 16:00. */@RestControllerpublic class CalculatorController { private final Logger logger = LoggerFactory.getLogger(getClass()); @Resource private DiscoveryClient client; @RequestMapping(&quot;/add&quot;) public int add(int a, int b){ //加运算 int result = a + b; //输出服务信息 ServiceInstance instance = client.getLocalServiceInstance(); logger.info(&quot;uri={}，serviceId={}，result={}&quot;, instance.getUri(), instance.getServiceId(), result); //返回结果 return result; }}服务提供方02除了启动端口为2200外，其代码与服务提供方01的完全相同服务网关01这是第一个服务网关的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-07-zuul&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-gateway-01&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-zuul&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是第一个服务网关的配置文件 /src/main/resources/application.ymlserver: port: 4100spring: application: name: jadyer-api-gateway # 指定发布的微服务名（以后调用时，只需该名称即可访问该服务）zuul: ignored-services: &quot;*&quot; # 设置忽略的服务，即配置后将不会被路由（但对于明确配置在路由中的，将不会被忽略） routes: api-cal-url: # 基于 URL 的映射（这里自定义路由的名字为 api-cal-url，它可任意指定，唯一即可） path: /cal/** # http://127.0.0.1:4100/cal/add?a=7&amp;amp;b=17会路由至http://127.0.0.1:2100/add?a=7&amp;amp;b=17 url: http://127.0.0.1:2100/ api-add: # 基于 ServiceId 的映射（自定义路由的名字） path: /caladd/** # http://127.0.0.1:4100/caladd/add?a=6&amp;amp;b=16会路由至CalculatorServer服务的/add?a=6&amp;amp;b=16 serviceId: CalculatorServer CalculatorServer: # 基于 ServiceId 的映射（路由的名字等于 ServiceId 的情况下，serviceId 属性可以省略） path: /mycall/** # http://127.0.0.1:4100/mycall/add?a=5&amp;amp;b=15会路由至CalculatorServer服务的 /add?a=5&amp;amp;b=15 #serviceId: CalculatorServereureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true # 设置微服务调用地址为IP优先（缺省为false） lease-renewal-interval-in-seconds: 5 # 心跳时间，即服务续约间隔时间（缺省为30s） lease-expiration-duration-in-seconds: 15 # 发呆时间，即服务续约到期时间（缺省为90s） client: healthcheck: enabled: true # 开启健康检查（依赖spring-boot-starter-actuator） serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/ # 指定服务注册中心的地址这是第一个服务网关的 SpringBoot 启动类 ServiceGateway01BootStarp.javapackage com.jadyer.demo;import com.netflix.zuul.ZuulFilter;import org.springframework.boot.SpringApplication;import org.springframework.cloud.client.SpringCloudApplication;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;import org.springframework.context.annotation.Bean;//注意不是@EnableZuulServer@EnableZuulProxy//注意这里使用了更加简化的@SpringCloudApplication@SpringCloudApplicationpublic class ServiceGateway01BootStarp { /** * 这里的方法返回值，不能写成com.netflix.zuul.IZuulFilter * 可以写成com.netflix.zuul.ZuulFilter，或者com.jadyer.demo.GatewayFilter * 虽然语法上允许返回IZuulFilter，但实际测试发现返回IZuulFilter时，网关功能却没有生效 */ @Bean public ZuulFilter gatewayFilter() { return new GatewayFilter(); } public static void main(String[] args) { SpringApplication.run(ServiceGateway01BootStarp.class, args); }}这是第一个服务网关中，用于控制接口访问权限的过滤器 GatewayFilter.javapackage com.jadyer.demo;import com.netflix.zuul.ZuulFilter;import com.netflix.zuul.context.RequestContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.servlet.http.HttpServletRequest;/** * 利用Zuul的过滤器，可以实现对外服务的安全控制 * ------------------------------------------------------------------------- * 这里实现了在请求被路由之前检查请求中是否有accesstoken参数 * 若有就进行路由，若没有就拒绝访问，返回401 Unauthorized错误 * http://127.0.0.1:4100/mycall/add?a=11&amp;amp;b=22：返回&quot;权限不足&quot; * http://127.0.0.1:4100/mycall/add?a=11&amp;amp;b=22&amp;amp;accesstoken=token：返回正常 * ------------------------------------------------------------------------- * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/14 15:05. */public class GatewayFilter extends ZuulFilter { private Logger log = LoggerFactory.getLogger(getClass()); /** * 如下所示，Zuul定义了四种不同生命周期的过滤器类型 * pre ：可以在请求被路由之前调用 * routing：在路由请求时候被调用 * post ：在routing和error过滤器之后被调用 * error ：处理请求时发生错误时被调用 */ @Override public String filterType() { return &quot;pre&quot;; } @Override public int filterOrder() { //通过int值来定义过滤器的执行顺序 return 0; } @Override public boolean shouldFilter() { //设置该过滤器总是生效，即总是执行拦截请求 return true; } /** * 过滤器的具体逻辑 */ @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info(String.format(&quot;收到 %s 请求 %s&quot;, request.getMethod(), request.getRequestURL().toString())); Object accessToken = request.getParameter(&quot;accesstoken&quot;); if(accessToken == null) { ctx.getResponse().setContentType(&quot;text/html;charset=UTF-8&quot;); log.warn(&quot;accesstoken为空&quot;); //令zuul过滤该请求，不对其进行路由 ctx.setSendZuulResponse(false); //设置其返回的错误码和报文体 //这里没有设置应答码为401，是因为401会导致客户端走到它的断路器里面（HystrixCalculatorService） //所有设置为200，让应答报文体跳过客户端的断路器，返回给前台 ctx.setResponseStatusCode(200); ctx.setResponseBody(&quot;权限不足&quot;); return null; } log.info(&quot;accesstoken验证通过&quot;); return null; }}服务网关02除了启动端口为4200外，其代码与服务网关01的完全相同服务消费方这是服务消费方的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-07-zuul&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-client&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- spring-cloud-starter-feign的内部已经包含了spring-cloud-starter-ribbon和spring-cloud-starter-hystrix --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-feign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是服务消费方的配置文件 /src/main/resources/application.ymlserver: port: 3100spring: application: name: client-consumer-feigneureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15 client: healthcheck: enabled: true serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/这是服务消费方 SpringBoot 启动类 ServiceClientBootStarp.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.feign.EnableFeignClients;//开启Feign功能（无需显式@EnableCircuitBreaker，其已含此功能）@EnableFeignClients@EnableEurekaClient@SpringBootApplicationpublic class ServiceClientBootStarp { public static void main(String[] args) { SpringApplication.run(ServiceClientBootStarp.class, args); }}这是服务消费方的，包含了断路器配置的，调用服务网关的实现 CalculatorService.javapackage com.jadyer.demo.feign;import org.springframework.cloud.netflix.feign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;//绑定該接口到服务网关的jadyer-api-gateway服务，并通知Feign组件对该接口进行代理（不需要编写接口实现）@FeignClient(value=&quot;jadyer-api-gateway&quot;, fallback=CalculatorService.HystrixCalculatorService.class)public interface CalculatorService { ////@PathVariable這種也是支持的 //@RequestMapping(value=&quot;/mycall/add/{a}&quot;, method=RequestMethod.GET) //int myadd(@PathVariable(&quot;a&quot;) int a, @RequestParam(&quot;b&quot;) int b, @RequestParam(&quot;accesstoken&quot;) String accesstoken); //通过SpringMVC的注解来配置所綁定的服务下的具体实现 @RequestMapping(value=&quot;/mycall/add&quot;, method=RequestMethod.GET) String myadd(@RequestParam(&quot;a&quot;) int a, @RequestParam(&quot;b&quot;) int b, @RequestParam(&quot;accesstoken&quot;) String accesstoken); /** * 这里采用和SpringCloud官方文档相同的做法，把fallback类作为内部类放入Feign接口中 * http://cloud.spring.io/spring-cloud-static/Camden.SR6/#spring-cloud-feign-hystrix * （也可以外面独立定义该类，个人觉得没必要，这种东西写成内部类最合适） */ @Component class HystrixCalculatorService implements CalculatorService { @Override public String myadd(@RequestParam(&quot;a&quot;) int a, @RequestParam(&quot;b&quot;) int b, @RequestParam(&quot;accesstoken&quot;) String accesstoken) { return &quot;负999&quot;; } }}这是服务消费方的调用示例 ConsumerController.javapackage com.jadyer.demo.feign;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * 服务调用方 * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/10 18:23. */@RestController@RequestMapping(&quot;/demo/feign&quot;)public class ConsumerController { @Resource private CalculatorService calculatorService; @RequestMapping(&quot;/toadd&quot;) String toadd(int a, int b, String accesstoken){ return calculatorService.myadd(a, b, accesstoken); }}验证分别用浏览器多次访问以下地址，然后观察两个服务提供方、两个服务网关的控制台输出即可http://127.0.0.1:4100/cal/add?a=7&amp;amp;b=17http://127.0.0.1:4100/cal/add?a=7&amp;amp;b=17&amp;amp;accesstoken=00http://127.0.0.1:4100/caladd/add?a=6&amp;amp;b=16http://127.0.0.1:4100/caladd/add?a=6&amp;amp;b=16&amp;amp;accesstoken=00http://127.0.0.1:4200/mycall/add?a=5&amp;amp;b=15http://127.0.0.1:4200/mycall/add?a=5&amp;amp;b=15&amp;amp;accesstoken=00http://127.0.0.1:3100/demo/feign/toadd?a=22&amp;amp;b=56http://127.0.0.1:3100/demo/feign/toadd?a=22&amp;amp;b=56&amp;amp;accesstoken=00" }, { "title": "SpringCloud系列-06之断路器Hystrix", "url": "/posts/springcloud-hystrix/", "categories": "SpringCloud", "tags": "SpringCloud", "date": "2020-04-14 12:10:00 +0800", "snippet": " 前言 Hystrix的介绍 Hystrix的隔离策略 Hystrix的配置参数 示例代码 注册中心 服务提供方 服务消费方Ribbon的断路 服务消费方Feign的断路 验证前言微服务架构中，一般都存在着很多的服务单元这样就有可能出现一个单元因为网络原因或自身问题而出现故障或延迟，导致调用方的对外服务也出现延迟如果此时调用方的请求不断增加，时间一长就会出现由于等待故障方响应而形成任务积压，最终导致调用方自身服务的瘫痪为了解决这种问题：便出现了断路器（或者叫熔断器，Cricuit Breaker）模式断路器模式源于 Martin Fowler 的 Circuit Breaker 一文我们日常生活中的断路器，本身是一种开关装置，用于在电路上保护线路过载当线路中有电器发生短路时，它能够及时切断故障电路，防止发生过载、发热、甚至起火等严重后果而微服务架构中的断路器，其作用是：当某个服务单元发生故障（类似用电器短路）之后通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待这就不会使得线程被故障服务长时间占用而不释放，避免了故障在分布式系统中的蔓延Hystrix的介绍Hystrix 正是 Netflix 开源的 javanica 提供的微服务框架套件之一它是由 Java 实现的，用来处理分布式系统发生故障或延迟时的容错库它提供了 断路器、资源隔离、自我修复 三大功能 断路器实际可初步理解为快速失败，快速失败是防止资源耗尽的关键点当 Hystrix 发现在过去某段时间内对服务 AA 的调用出错率达到阀值时，它就会“熔断”该服务后续任何向服务 AA 的请求都会快速失败，而不是白白让调用线程去等待 资源隔离首先，Hystrix 对每一个依赖服务都配置了一个线程池，对依赖服务的调用会在线程池中执行比如，服务 AA 的线程池大小为20，那么 Hystrix 会最多允许有20个容器线程调用服务 AA（超出20，它会拒绝并快速失败）这样即使服务 AA 长时间未响应，容器最多也只能堵塞20个线程，剩余的线程仍然可以处理用户请求 自我修复处于熔断状态的服务，在经过一段时间后，Hystrix 会让其进入“半关闭”状态（即允许少量请求通过）然后统计调用的成功率，若每个请求都能成功，Hystrix 会恢复该服务，从而达到自我修复的效果其中：在服务被熔断到进入“半关闭”状态之间的时间，就是留给开发人员排查错误并恢复故障的时间Hystrix的隔离策略Hystrix 基于命令模式 HystrixCommand 来包装依赖调用逻辑，其每个命令在单独线程中或信号授权下执行（Command 是在 Receiver 和 Invoker 之间添加的中间层，Command 实现了对 Receiver 的封装）Hystrix 支持两种隔离策略：线程池隔离和信号量隔离（都是限制对共享资源的并发访问量） ThreadPool根据配置把不同命令分配到不同的线程池中，这是比较常用的隔离策略，其优点是隔离性好，并且可以配置断路某个依赖被设置断路之后，系统不会再尝试新起线程运行它，而是直接提示失败，或返回fallback值它的缺点是新起线程执行命令，在执行时必然涉及上下文的切换，这会造成一定的性能消耗但是 Netflix 做过实验，这种消耗对比其带来的价值是完全可以接受的，具体的数据参见 Hystrix-Wiki Semaphores顾名思义就是使用一个信号量来做隔离开发者可以限制系统对某一个依赖的最高并发数，这个基本上就是一个限流的策略每次调用依赖时都会检查一下是否到达信号量的限制值，如达到，则拒绝该策略的优点是不新起线程执行命令，减少上下文切换，缺点是无法配置断路，每次都一定会去尝试获取信号量Hystrix的配置参数Hystrix 的大部分配置都是 hystrix.command.[HystrixCommandKey] 开头其中 [HystrixCommandKey] 是可变的，默认是 default，即：hystrix.command.default（对于 Zuul 而言，CommandKey 就是 service id）它常见的有以下几个配置 hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds用来设置 thread 和 semaphore 两种隔离策略的超时时间，默认值是1000建议设置这个参数，在 Hystrix-1.4.0 之前，semaphore-isolated 隔离策略是不能超时的，1.4.0 开始 semaphore-isolated 也支持超时时间了 hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests此值并非 TPS、QPS、RPS 等都是相对值，它指的是 1 秒时间窗口内的事务 / 查询 / 请求，它是一个绝对值，无时间窗口相当于亚毫秒级的，指任意时间点允许的并发数，当请求达到或超过该设置值后，其其余就会被拒绝，默认值是100 hystrix.command.default.execution.timeout.enabled是否开启超时，默认为true hystrix.command.default.execution.isolation.thread.interruptOnTimeout发生超时是是否中断线程，默认是true hystrix.command.default.execution.isolation.thread.interruptOnCancel取消时是否中断线程，默认是false hystrix.command.default.circuitBreaker.requestVolumeThreshold当在配置时间窗口内达到此数量的失败后，进行短路，默认20个 hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds短路多久以后开始尝试是否恢复，默认5s hystrix.command.default.circuitBreaker.errorThresholdPercentage出错百分比阈值，当达到此阈值后，开始短路，默认50% hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests调用线程允许请求 HystrixCommand.GetFallback() 的最大数量，默认10，超出时将会有异常抛出注意：该项配置对于 thread 隔离模式也起作用 以上就是列举的一些常见配置，更多内容可参考：https://github.com/Netflix/Hystrix/wiki/Configuration示例代码示例代码如下（也可以直接从 Github 下载：https://github.com/v5java/demo-cloud-06-hystrix）它是由四个模块组成的 Maven 工程，其中包含一个注册中心、一个服务提供者、兩个服务消费者这是公共的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-06-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;service-client-01&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-client-02&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-discovery&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-server&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Camden.SR6&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt;注册中心这是注册中心的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-06-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是注册中心的配置文件 /src/main/resources/application.ymlserver: port: 1100eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 续期时间，即扫描失效服务的间隔时间（缺省为60*1000ms） client: # 设置是否从注册中心获取注册信息（缺省true） # 因为这是一个单点的EurekaServer，不需要同步其它EurekaServer节点的数据，故设为false fetch-registry: false # 设置是否将自己作为客户端注册到注册中心（缺省true） # 这里为不需要（查看@EnableEurekaServer注解的源码，会发现它间接用到了@EnableDiscoveryClient） register-with-eureka: false # 在未设置defaultZone的情况下，注册中心在本例中的默认地址就是http://127.0.0.1:1100/eureka/ # 但奇怪的是，启动注册中心时，控制台还是会打印这个地址的节点：http://localhost:8761/eureka/ # 而实际服务端注册时，要使用1100端口的才能注册成功，8761端口的会注册失败并报告异常 serviceUrl: # 实际测试：若修改尾部的eureka为其它的，比如/myeureka，注册中心启动没问题，但服务端在注册时会失败 # 报告异常：com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server defaultZone: http://127.0.0.1:${server.port}/eureka/这是注册中心的 SpringBoot 启动类 ServiceDiscoveryBootStrap.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;//创建服务注册中心@EnableEurekaServer@SpringBootApplicationpublic class ServiceDiscoveryBootStrap { public static void main(String[] args) { SpringApplication.run(ServiceDiscoveryBootStrap.class, args); }}服务提供方这是服务提供方的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-06-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-server&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是服务提供方的配置文件 /src/main/resources/application.ymlserver: port: 2100spring: application: name: CalculatorServer # 指定发布的微服务名（以后调用时，只需该名称即可访问该服务）eureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true # 设置微服务调用地址为IP优先（缺省为false） lease-renewal-interval-in-seconds: 5 # 心跳时间，即服务续约间隔时间（缺省为30s） lease-expiration-duration-in-seconds: 15 # 发呆时间，即服务续约到期时间（缺省为90s） client: healthcheck: enabled: true # 开启健康检查（依赖spring-boot-starter-actuator） serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/ # 指定服务注册中心的地址这是服务提供方的 SpringBoot 启动类 ServiceServerBootStarp.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * 通过 @EnableEurekaClient 注解，为服务提供方赋予注册和发现服务的能力 * ------------------------------------------------------------------------------------------------------------------ * 也可以使用org.springframework.cloud.client.discovery.@EnableDiscoveryClient注解 * 详见以下两篇文章的介绍 * http://cloud.spring.io/spring-cloud-static/Camden.SR3/#_registering_with_eureka * https://spring.io/blog/2015/01/20/microservice-registration-and-discovery-with-spring-cloud-and-netflix-s-eureka * ------------------------------------------------------------------------------------------------------------------ * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/9 16:00. */@EnableEurekaClient@SpringBootApplicationpublic class ServiceServerBootStarp { public static void main(String[] args) { SpringApplication.run(ServiceServerBootStarp.class, args); }}这是服务提供方暴露的数学运算服务 CalculatorController.javapackage com.jadyer.demo;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * 服务提供方暴露的数学运算服务 * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/9 16:00. */@RestControllerpublic class CalculatorController { private final Logger logger = LoggerFactory.getLogger(getClass()); @Resource private DiscoveryClient client; @RequestMapping(&quot;/add&quot;) public int add(int a, int b){ //加运算 int result = a + b; //输出服务信息 ServiceInstance instance = client.getLocalServiceInstance(); logger.info(&quot;uri={}，serviceId={}，result={}&quot;, instance.getUri(), instance.getServiceId(), result); //返回结果 return result; }}服务消费方Ribbon的断路这是服务消费方Ribbon的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-06-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-client-01&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-ribbon&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是服务消费方Ribbon的配置文件 /src/main/resources/application.ymlserver: port: 3100spring: application: name: client-consumer-ribboneureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15 client: healthcheck: enabled: true serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/这是服务消费方Ribbon的 SpringBoot 启动类 ServiceClient01BootStarp.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;//@SpringCloudApplication//开启断路器功能@EnableCircuitBreaker@EnableEurekaClient@SpringBootApplicationpublic class ServiceClient01BootStarp { //开启软均衡负载 @LoadBalanced @Bean RestTemplate restTemplate() { return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(ServiceClient01BootStarp.class, args); }}这是服务消费方Ribbon的，包含了断路器配置的，远程服务调用实现 CalculatorService.javapackage com.jadyer.demo.ribbon;import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;@Serviceclass CalculatorService { @Resource private RestTemplate restTemplate; //指定断路后的回调方法（回调方法必须与原方法参数类型相同、返回值类型相同、方法名可以不同） @HystrixCommand(fallbackMethod=&quot;addServiceToFallback&quot;) int addService(int a, int b){ String reqURL = &quot;http://CalculatorServer/add?a=&quot; + a + &quot;&amp;amp;b=&quot; + b; return restTemplate.getForEntity(reqURL, Integer.class).getBody(); } public int addServiceToFallback(int aa, int bb){ return -999; }}这是服务消费方Ribbon的调用示例 ConsumerController.javapackage com.jadyer.demo.ribbon;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * 服务调用方 * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/10 18:23. */@RestController@RequestMapping(&quot;/demo/ribbon&quot;)public class ConsumerController { @Resource private CalculatorService calculatorService; @RequestMapping(&quot;/toadd&quot;) int toadd(int a, int b){ return calculatorService.addService(a, b); }}服务消费方Feign的断路这是服务消费方Feign的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-06-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-client-02&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- spring-cloud-starter-feign的内部已经包含了spring-cloud-starter-ribbon和spring-cloud-starter-hystrix --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-feign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是服务消费方Feign的配置文件 /src/main/resources/application.ymlserver: port: 3200spring: application: name: client-consumer-feigneureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15 client: healthcheck: enabled: true serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/这是服务消费方Feign的 SpringBoot 启动类 ServiceClient02BootStarp.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.feign.EnableFeignClients;//开启Feign功能（无需显式@EnableCircuitBreaker，其已含此功能）@EnableFeignClients@EnableEurekaClient@SpringBootApplicationpublic class ServiceClient02BootStarp { public static void main(String[] args) { SpringApplication.run(ServiceClient02BootStarp.class, args); }}这是服务消费方Feign的，包含了断路器配置的，远程服务调用实现 CalculatorService.javapackage com.jadyer.demo.feign;import org.springframework.cloud.netflix.feign.FeignClient;import org.springframework.stereotype.Component;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;//绑定該接口到CalculatorServer服务，并通知Feign组件对该接口进行代理（不需要编写接口实现）@FeignClient(value=&quot;CalculatorServer&quot;, fallback=CalculatorService.HystrixCalculatorService.class)public interface CalculatorService { ////@PathVariable這種也是支持的 //@RequestMapping(value=&quot;/add/{a}&quot;, method=RequestMethod.GET) //int myadd(@PathVariable(&quot;a&quot;) int a, @RequestParam(&quot;b&quot;) int b); //通过SpringMVC的注解来配置所綁定的服务下的具体实现 @RequestMapping(value=&quot;/add&quot;, method=RequestMethod.GET) int myadd(@RequestParam(&quot;a&quot;) int a, @RequestParam(&quot;b&quot;) int b); /** * 这里采用和SpringCloud官方文档相同的做法，把fallback类作为内部类放入Feign接口中 * http://cloud.spring.io/spring-cloud-static/Camden.SR6/#spring-cloud-feign-hystrix * （也可以外面独立定义该类，个人觉得没必要，这种东西写成内部类最合适） */ @Component class HystrixCalculatorService implements CalculatorService { @Override public int myadd(@RequestParam(&quot;a&quot;) int a, @RequestParam(&quot;b&quot;) int b) { return -999; } }}這是服务消费方Feign的调用示例 ConsumerController.javapackage com.jadyer.demo.feign;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * 服务调用方 * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/10 18:23. */@RestController@RequestMapping(&quot;/demo/feign&quot;)public class ConsumerController { @Resource private CalculatorService calculatorService; @RequestMapping(&quot;/toadd&quot;) int toadd(int a, int b){ return calculatorService.myadd(a, b); }}验证先不使用断路器，然后启动注册中心、服务提供方、两个服务消费方，然后分别访问以下两个接口http://10.16.64.133:3100/demo/ribbon/toadd?a=11&amp;amp;b=22http://10.16.64.133:3200/demo/feign/toadd?a=11&amp;amp;b=22我们会发现都正常的返回了计算结果：33然后停掉服务提供方，再访问两个接口，我们会看到下面的报警内容# Ribbon会报告如下内容Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Sat Apr 15 11:12:48 CST 2017There was an unexpected error (type=Internal Server Error, status=500).I/O error on GET request for &quot;http://CalculatorServer/add&quot;: Connection refused: connect; nested exception is java.net.ConnectException: Connection refused: connect# Feign会报告如下内容Whitelabel Error PageThis application has no explicit mapping for /error, so you are seeing this as a fallback.Sat Apr 15 11:12:48 CST 2017There was an unexpected error (type=Internal Server Error, status=500).CalculatorService#myadd(int,int) timed-out and no fallback available.然后我们再启用断路器，并访问两个接口（此时服务提供方是关闭的），都会看到该应答：-999" }, { "title": "SpringCloud系列-05之服务消费Ribbon和Feign", "url": "/posts/springcloud-ribbon-feign/", "categories": "SpringCloud", "tags": "SpringCloud", "date": "2020-01-19 12:10:00 +0800", "snippet": " Ribbon Feign 示例代码 注册中心 服务提供方01 服务提供方02 服务消费方Ribbon 服务消费方Feign 验证服务消费和软负载均衡RibbonRibbon 是一个基于 HTTP 和 TCP 客户端的负载均衡器它可以在客户端配置 ribbonServerList（服务端列表），然后轮询请求以实现均衡负载它在联合 Eureka 使用时ribbonServerList 会被 DiscoveryEnabledNIWSServerList 重写，扩展成从 Eureka 注册中心获取服务端列表同时它也会用 NIWSDiscoveryPing 来取代 IPing，它将职责委托给 Eureka 来确定服务端是否已经启动FeignSpring Cloud Netflix 的微服务都是以 HTTP 接口的形式暴露的，所以可以用 Apache 的 HttpClient 或 Spring 的 RestTemplate 去調用而 Feign 是一個使用起來更加方便的 HTTP 客戶端，它用起來就好像調用本地方法一樣，完全感覺不到是調用的遠程方法总结起来就是：发布到注册中心的服务方接口，是 HTTP 的，也可以不用 Ribbon 或者 Feign，直接浏览器一样能够访问只不过 Ribbon 或者 Feign 调用起来要方便一些，最重要的是：它俩都支持软负载均衡 注意：spring-cloud-starter-feign 里面已经包含了 spring-cloud-starter-ribbon（Feign 中也使用了 Ribbon）示例代码示例代码如下（也可以直接从 Github 下载：https://github.com/v5java/demo-cloud-05-ribbon-feign）它是由五個模块组成的 Maven 工程，其中包含一个注册中心、兩个服务提供者、兩个服务消费者（分别由Ribbon和Feign实现）这是公共的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-05&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;service-client-01&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-client-02&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-discovery&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-server-01&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-server-02&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.5.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Camden.SR6&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt;注册中心這是註冊中心的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-05&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;這是註冊中心的配置文件 /src/main/resources/application.ymlserver: port: 1100eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 续期时间，即扫描失效服务的间隔时间（缺省为60*1000ms） client: # 设置是否从注册中心获取注册信息（缺省true） # 因为这是一个单点的EurekaServer，不需要同步其它EurekaServer节点的数据，故设为false fetch-registry: false # 设置是否将自己作为客户端注册到注册中心（缺省true） # 这里为不需要（查看@EnableEurekaServer注解的源码，会发现它间接用到了@EnableDiscoveryClient） register-with-eureka: false # 在未设置defaultZone的情况下，注册中心在本例中的默认地址就是http://127.0.0.1:1100/eureka/ # 但奇怪的是，启动注册中心时，控制台还是会打印这个地址的节点：http://localhost:8761/eureka/ # 而实际服务端注册时，要使用1100端口的才能注册成功，8761端口的会注册失败并报告异常 serviceUrl: # 实际测试：若修改尾部的eureka为其它的，比如/myeureka，注册中心启动没问题，但服务端在注册时会失败 # 报告异常：com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server defaultZone: http://127.0.0.1:${server.port}/eureka/这是註冊中心的 SpringBoot 启动类 ServiceDiscoveryBootStrap.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;//创建服务注册中心@EnableEurekaServer@SpringBootApplicationpublic class ServiceDiscoveryBootStrap { public static void main(String[] args) { SpringApplication.run(ServiceDiscoveryBootStrap.class, args); }}服务提供方01这是第一个服务提供方的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-05&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-server-01&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是第一个服务提供方的配置文件 /src/main/resources/application.ymlserver: port: 2100spring: application: name: CalculatorServer # 指定发布的微服务名（以后调用时，只需该名称即可访问该服务）eureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true # 设置微服务调用地址为IP优先（缺省为false） lease-renewal-interval-in-seconds: 5 # 心跳时间，即服务续约间隔时间（缺省为30s） lease-expiration-duration-in-seconds: 15 # 发呆时间，即服务续约到期时间（缺省为90s） client: healthcheck: enabled: true # 开启健康检查（依赖spring-boot-starter-actuator） serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/ # 指定服务注册中心的地址这是第一个服务提供方的 SpringBoot 启动类 ServiceServer01BootStarp.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * 通过 @EnableEurekaClient 注解，为服务提供方赋予注册和发现服务的能力 * ------------------------------------------------------------------------------------------------------------------ * 也可以使用org.springframework.cloud.client.discovery.@EnableDiscoveryClient注解 * 详见以下两篇文章的介绍 * http://cloud.spring.io/spring-cloud-static/Camden.SR3/#_registering_with_eureka * https://spring.io/blog/2015/01/20/microservice-registration-and-discovery-with-spring-cloud-and-netflix-s-eureka * ------------------------------------------------------------------------------------------------------------------ * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/9 16:00. */@EnableEurekaClient@SpringBootApplicationpublic class ServiceServer01BootStarp { public static void main(String[] args) { SpringApplication.run(ServiceServer01BootStarp.class, args); }}这是第一个服务提供方暴露的数学运算服務 CalculatorController.javapackage com.jadyer.demo;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * 服务提供方暴露的数学运算服务 * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/9 16:00. */@RestControllerpublic class CalculatorController { private final Logger logger = LoggerFactory.getLogger(getClass()); @Resource private DiscoveryClient client; @RequestMapping(&quot;/add&quot;) public int add(int a, int b){ //加运算 int result = a + b; //输出服务信息 ServiceInstance instance = client.getLocalServiceInstance(); logger.info(&quot;uri={}，serviceId={}，result={}&quot;, instance.getUri(), instance.getServiceId(), result); //返回结果 return result; }}服务提供方02除了启动端口为2200外，其代码与服务提供方01的完全相同服务消费方Ribbon這是服务消费方Ribbon的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-05&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-client-01&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-ribbon&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是服务消费方Ribbon的配置文件 /src/main/resources/application.ymlserver: port: 3100spring: application: name: client-consumer-ribboneureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15 client: healthcheck: enabled: true serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/这是服务消费方Ribbon的 SpringBoot 启动类 ServiceClient01BootStarp.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@EnableEurekaClient@SpringBootApplicationpublic class ServiceClient01BootStarp { //开启软均衡负载 @LoadBalanced @Bean RestTemplate restTemplate() { return new RestTemplate(); } public static void main(String[] args) { SpringApplication.run(ServiceClient01BootStarp.class, args); }}这是服务消费方Ribbon的遠程服务調用實現 CalculatorService.javapackage com.jadyer.demo.ribbon;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;import javax.annotation.Resource;@Serviceclass CalculatorService { @Resource private RestTemplate restTemplate; int addService(int a, int b){ String reqURL = &quot;http://CalculatorServer/add?a=&quot; + a + &quot;&amp;amp;b=&quot; + b; return restTemplate.getForEntity(reqURL, Integer.class).getBody(); }}這是服务消费方Ribbon的調用示例 ConsumerController.javapackage com.jadyer.demo.ribbon;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * 服务调用方 * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/10 18:23. */@RestController@RequestMapping(&quot;/demo/ribbon&quot;)public class ConsumerController { @Resource private CalculatorService calculatorService; @RequestMapping(&quot;/toadd&quot;) int toadd(int a, int b){ return calculatorService.addService(a, b); }}服务消费方Feign這是服务消费方Feign的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-05&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-client-02&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-feign&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是服务消费方Feign的配置文件 /src/main/resources/application.ymlserver: port: 3200spring: application: name: client-consumer-feigneureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15 client: healthcheck: enabled: true serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/这是服务消费方Feign的 SpringBoot 启动类 ServiceClient02BootStarp.javapackage com.jadyer.demo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.feign.EnableFeignClients;//开启Feign功能@EnableFeignClients@EnableEurekaClient@SpringBootApplicationpublic class ServiceClient02BootStarp { public static void main(String[] args) { SpringApplication.run(ServiceClient02BootStarp.class, args); }}这是服务消费方Feign的遠程服务調用實現 CalculatorService.javapackage com.jadyer.demo.feign;import org.springframework.cloud.netflix.feign.FeignClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;//绑定該接口到CalculatorServer服务，并通知Feign组件对该接口进行代理（不需要编写接口实现）@FeignClient(value=&quot;CalculatorServer&quot;)interface CalculatorService { ////@PathVariable這種也是支持的 //@RequestMapping(value=&quot;/add/{a}&quot;, method=RequestMethod.GET) //int myadd(@PathVariable(&quot;a&quot;) int a, @RequestParam(&quot;b&quot;) int b); //通过SpringMVC的注解来配置所綁定的服务下的具体实现 @RequestMapping(value=&quot;/add&quot;, method=RequestMethod.GET) int myadd(@RequestParam(&quot;a&quot;) int a, @RequestParam(&quot;b&quot;) int b);}這是服务消费方Feign的調用示例 ConsumerController.javapackage com.jadyer.demo.feign;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * 服务调用方 * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/10 18:23. */@RestController@RequestMapping(&quot;/demo/feign&quot;)public class ConsumerController { @Resource private CalculatorService calculatorService; @RequestMapping(&quot;/toadd&quot;) int toadd(int a, int b){ return calculatorService.myadd(a, b); }}验证服务消费和软负载均衡本文中的示例（Ribbon和Feign）都會將請求走软负载均衡后，打到服务端验证方式就是：分別多次訪問下面的兩個服务消费URL，兩個服务端打印的請求日誌是均等輸出的http://10.16.64.133:3100/demo/ribbon/toadd?a=11&amp;amp;b=22http://10.16.64.133:3200/demo/feign/toadd?a=11&amp;amp;b=22若没有走 Ribbon 或者 Feigin，而是直接浏览器访问服务方的接口如下两个地址，也可以访问成功，只不过无法享受到软负载均衡http://10.16.64.133:2100/add?a=3&amp;amp;b=13http://10.16.64.133:2200/add?a=3&amp;amp;b=13最後，補充一張註冊中心的頁面截圖：" }, { "title": "SpringCloud系列-04之注册中心Eureka高可用", "url": "/posts/springcloud-eureka-highavailability/", "categories": "SpringCloud", "tags": "SpringCloud", "date": "2020-01-18 12:10:00 +0800", "snippet": " 简介 Zone 示例代码 注册中心01 注册中心02 服务提供方01 服务提供方02 简介Eureka Server 也支持运行多实例，并以互相注册的方式（即伙伴机制），来实现高可用的部署即每一台 Eureka 都在配置中指定另一个 Eureka 地址作为伙伴，它在启动时会向伙伴节点获取注册列表如此一来，Eureka 集群新加机器时，就不用担心注册列表的完整性所以：我们只需要在 Eureke Server 里面配置其他可用的 serviceUrl，就实现了注册中心的高可用详见：http://cloud.spring.io/spring-cloud-static/spring-cloud.html#_peer_awarenessZone上面提到 serviceUrl，那就顺便说下 defaultZoneEureka 有一个 Region 和 Zone 的概念，你可以理解为现实中的大区（Region）和机房（Zone）Eureka Client 在启动时需要指定 Zone，它会优先请求自己 Zone 的 Eureka Server 获取注册列表同样的，Eureka Server 在启动时也需要指定 Zone，如果没有指定的话，其会默认使用 defaultZone详见源码中的 getEurekaServerServiceUrls() 方法：https://github.com/spring-cloud/spring-cloud-netflix/blob/master/spring-cloud-netflix-eureka-client/src/main/java/org/springframework/cloud/netflix/eureka/EurekaClientConfigBean.java示例代码这是演示的是一个由四个模块组成的 Maven 工程，其中包含两个注册中心和两个服务提供者如下图所示这是公共的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-04&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;service-discovery-01&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-discovery-02&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-server-01&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-server-02&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.3.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Camden.SR4&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt;注册中心01这是第一个注册中心的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-04&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-discovery-01&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是第一个注册中心的 SpringBoot 启动类 ServiceDiscovery01BootStrap.javapackage com.jadyer.demo;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;//创建服务注册中心@EnableEurekaServer@SpringBootApplicationpublic class ServiceDiscovery01BootStrap { public static void main(String[] args) { new SpringApplicationBuilder(ServiceDiscovery01BootStrap.class).run(args); }}这是第一个注册中心的配置文件 /src/main/resources/application.ymlserver: port: 1100eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 续期时间，即扫描失效服务的间隔时间（缺省为60*1000ms） client: # 设置是否从注册中心获取注册信息（缺省true） # 因为这是一个单点的EurekaServer，不需要同步其它EurekaServer节点的数据，故设为false # fetch-registry: false # 设置是否将自己作为客户端注册到注册中心（缺省true） # 这里为不需要（查看@EnableEurekaServer注解的源码，会发现它间接用到了@EnableDiscoveryClient） register-with-eureka: false # 在未设置defaultZone的情况下，注册中心在本例中的默认地址就是http://127.0.0.1:1100/eureka/ # 但奇怪的是，启动注册中心时，控制台还是会打印这个地址的节点：http://localhost:8761/eureka/ # 而实际服务端注册时，要使用1100端口的才能注册成功，8761端口的会注册失败并报告异常 serviceUrl: # 实际测试：若修改尾部的eureka为其它的，比如/myeureka，注册中心启动没问题，但服务端在注册时会失败 # 报告异常：com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server defaultZone: http://127.0.0.1:1200/eureka/注册中心02其大部分代码与注册中心01相同，不同的有以下两处 启动端口为1200 eureka.client.serviceUrl.defaultZone=http://127.0.0.1:1100/eureka/（指向到伙伴那里）服务提供方01这是第一个服务提供方的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-04&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-server-01&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是第一个服务提供方的 SpringBoot 启动类 ServiceServer01BootStarp.javapackage com.jadyer.demo;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * 通过 @EnableEurekaClient 注解，为服务提供方赋予注册和发现服务的能力 * ------------------------------------------------------------------------------------------------------------------ * 也可以使用org.springframework.cloud.client.discovery.@EnableDiscoveryClient注解 * 详见以下两篇文章的介绍 * http://cloud.spring.io/spring-cloud-static/Camden.SR3/#_registering_with_eureka * https://spring.io/blog/2015/01/20/microservice-registration-and-discovery-with-spring-cloud-and-netflix-s-eureka * ------------------------------------------------------------------------------------------------------------------ * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/9 16:00. */@EnableEurekaClient@SpringBootApplicationpublic class ServiceServer01BootStarp { public static void main(String[] args) { new SpringApplicationBuilder(ServiceServer01BootStarp.class).run(args); }}这是第一个服务提供方的配置文件 /src/main/resources/application.ymlserver: port: 2100spring: application: name: CalculatorServer # 指定发布的微服务名（以后调用时，只需该名称即可访问该服务）eureka: instance: instance-id: ${spring.application.name}:${server.port} prefer-ip-address: true # 设置微服务调用地址为IP优先（缺省为false） lease-renewal-interval-in-seconds: 5 # 心跳时间，即服务续约间隔时间（缺省为30s） lease-expiration-duration-in-seconds: 15 # 发呆时间，即服务续约到期时间（缺省为90s） client: healthcheck: enabled: true # 开启健康检查（依赖spring-boot-starter-actuator） serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/ # 指定服务注册中心的地址这是第一个服务提供方暴露的数学运算服务 CalculatorController.javapackage com.jadyer.demo;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * 服务提供方暴露的数学运算服务 * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/9 16:00. */@RestControllerpublic class CalculatorController { private final Logger logger = LoggerFactory.getLogger(getClass()); @Resource private DiscoveryClient client; @RequestMapping(&quot;/add&quot;) public int add(int a, int b){ //加运算 int result = a + b; //输出服务信息 ServiceInstance instance = client.getLocalServiceInstance(); logger.info(&quot;uri={}，serviceId={}，result={}&quot;, instance.getUri(), instance.getServiceId(), result); //返回结果 return result; }}服务提供方02其大部分代码与服务提供方01相同，不同的有以下两处 启动端口为2200 eureka.client.serviceUrl.defaultZone=http://127.0.0.1:1200/eureka/（也可配成1100，再看效果，是一样的）补充一下：服务提供方配置成这样也可以eureka.client.serviceUrl.defaultZone=http://127.0.0.1:1100/eureka/,http://127.0.0.1:1200/eureka/至于验证，先启动两个注册中心（启动时会报错，不过没关系，这是由于它找不到伙伴），再启动服务提供方然后看两个注册中心 Eureka 首页的注册服务列表，就会发现会被自动同步" }, { "title": "SpringCloud系列-03之注册中心Eureka进阶", "url": "/posts/springcloud-eureka-advance/", "categories": "SpringCloud", "tags": "SpringCloud", "date": "2020-01-17 12:10:00 +0800", "snippet": " 自我保护模式 踢出已关停的节点 注册服务慢的问题 服务状态UNKNOWN 首页显示的微服务名 首页显示的微服务链接自我保护模式Eureka 在设计时，认为分布式环境的网络是不可靠的，可能会出现网络原因导致 EurekaServer 没有收到实例的心跳而这却并不能说明实例就宕了，所以 EurekaServer 缺省会打开保护模式，它主要是网络分区场景下的一种保护一旦进入保护模式，EurekaServer 将会尝试保护其服务注册表中的信息，不再删除里面的数据（即不会注销任何微服务）相关介绍，详见：https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication在这种机制下，它仍然鼓励客户端再去尝试调用这个所谓 down 状态的实例，若确实调用失败，那么断路器就派上用场了关于断路器，在接下来的系列文章中，我会详细介绍并演示通过修改注册中心的配置文件 application.yml，即可打开或关闭注册中心的自我保护模式eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开）踢出已关停的节点自我保护模式打开时，已关停节点是会一直显示在 Eureka 首页的关闭自我保护模式后，由于其默认的心跳周期比较长等原因，要过一会儿才会发现已关停节点被自动踢出了若想尽快的及时踢出，那就只有修改默认的心跳周期参数了，如下所示注册中心的配置文件 application.yml 需要修改的地方为eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 续期时间，即扫描失效服务的间隔时间（缺省为60*1000ms）微服务的配置文件 application.yml 需要修改的地方为eureka: instance: lease-renewal-interval-in-seconds: 5 # 心跳时间，即服务续约间隔时间（缺省为30s） lease-expiration-duration-in-seconds: 15 # 发呆时间，即服务续约到期时间（缺省为90s） client: healthcheck: enabled: true # 开启健康检查（依赖spring-boot-starter-actuator）关于续期、心跳、发呆时间的关系，详见上一篇文章中的有关分析：https://jadyer.cn/2017/01/16/springcloud-eureka/ 注意：更改 Eureka Server 的更新频率将打破注册中心的的自我保护功能　　　生产环境不建议自定义这些配置，详见https://github.com/spring-cloud/spring-cloud-netflix/issues/373注册服务慢的问题修改微服务的 eureka.instance.lease-renewal-interval-in-seconds 参数（即心跳时间），便可解决此问题详见：http://cloud.spring.io/spring-cloud-static/Camden.SR4/#_why_is_it_so_slow_to_register_a_service服务状态UNKNOWN如果把微服务的 eureka.client.healthcheck.enabled 属性配置在 bootstrap.yml 里面，可能会引起一些不良反应比如，实际测试发现，Eureka 首页显示的服务状态，本应是 UP(1)，却变成大红色的粗体 UNKNOWN(1) Tips：bootstrap.yml 通常会在连接 Spring Cloud Config 搭建的配置中心时使用，接下来的本系列文章中会有介绍和演示首页显示的微服务名Eureka 首页显示的微服务名默认为：机器主机名:应用名称:应用端口也就是：${spring.cloud.client.hostname}:${spring.application.name}:${spring.application.instance_id:${server.port}}我们也可以修改微服务的配置文件，定制它注册到注册中心时显示的名字，如下所示eureka: instance: # instance-id: ${spring.application.name} # 修改显示的微服务名为：应用名称 instance-id: ${spring.cloud.client.ipAddress}:${server.port} # 修改显示的微服务名为：IP:端口同样可以知道，两个相同的服务（端口不同），如果注册时设置的都是 eureka.instance.instance-id=${spring.application.name}那么 Eureka 首页只会看到一个服务名字，而无法区分有几个实例注册上来了（因为注册上来的实例名都是相同的），这是要注意的首页显示的微服务链接既然微服务显示的名称允许修改，那么其对应的点击链接，也是可以修改的同样的，还是修改微服务的配置文件，如下所示eureka: instance: # ip-address: 192.168.6.66 # 只有prefer-ip-address=true时才会生效 prefer-ip-address: true # 设置微服务调用地址为IP优先（缺省为false）Eureka 首页显示的微服务调用地址，默认是这样的：http://jadyer-pc:2100/info而在设置 prefer-ip-address=true 之后，调用地址会变成：http://10.16.18.95:2100/info这时若再设置 ip-address=192.168.6.66，则调用地址会变成：http://192.168.6.66:2100/info" }, { "title": "SpringCloud系列-02之注册中心Eureka", "url": "/posts/springcloud-eureka/", "categories": "SpringCloud", "tags": "SpringCloud", "date": "2020-01-09 12:10:00 +0800", "snippet": " 简介 示例代码 注册中心 服务提供方01 服务提供方02 验证简介Eureka 是 Netflix 开发的，一个基于 REST 服务的，服务注册与发现的组件它主要包括两个组件：Eureka Server 和 Eureka Client Eureka Client：一个Java客户端，用于简化与 Eureka Server 的交互（通常就是微服务中的客户端和服务端） Eureka Server：提供服务注册和发现的能力（通常就是微服务中的注册中心）各个微服务启动时，会通过 Eureka Client 向 Eureka Server 注册自己，Eureka Server 会存储该服务的信息也就是说，每个微服务的客户端和服务端，都会注册到 Eureka Server，这就衍生出了微服务相互识别的话题 同步：每个 Eureka Server 同时也是 Eureka Client（逻辑上的）　　　多个 Eureka Server 之间通过复制的方式完成服务注册表的同步，形成 Eureka 的高可用 识别：Eureka Client 会缓存 Eureka Server 中的信息　　　即使所有 Eureka Server 节点都宕掉，服务消费者仍可使用缓存中的信息找到服务提供者（笔者已亲测） 续约：微服务会周期性（默认30s）地向 Eureka Server 发送心跳以Renew（续约）自己的信息（类似于heartbeat） 续期：Eureka Server 会定期（默认60s）执行一次失效服务检测功能　　　它会检查超过一定时间（默认90s）没有Renew的微服务，发现则会注销该微服务节点Spring Cloud 已经把 Eureka 集成在其子项目 Spring Cloud Netflix 里面关于 Eureka 配置的最佳实践，可参考：https://github.com/spring-cloud/spring-cloud-netflix/issues/203更多介绍，可参考：http://cloud.spring.io/spring-cloud-static/Camden.SR4/#spring-cloud-eureka-server示例代码本文的例子只能用来尝尝鲜，更丰富的配置详见 Eureka 进阶篇：https://jadyer.cn/2017/01/17/springcloud-eureka-advance/这是演示的是一个由三个模块组成的 Maven 工程，其中包含一个注册中心和两个服务提供者如下图所示这是公共的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-02&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;module&amp;gt;service-discovery&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-server-01&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;service-server-02&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.3.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;Camden.SR4&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;/dependencyManagement&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;1.7&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;1.7&amp;lt;/target&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt;&amp;lt;/project&amp;gt;注册中心总体思路如下 SpringBoot启动类标注 @EnableEurekaServer 注解 设置自己本身不注册到注册中心ok，let`s drink code …这是注册中心的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-02&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-discovery&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是注册中心的 SpringBoot 启动类 ServiceDiscoveryBootStrap.javapackage com.jadyer.demo;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;//创建服务注册中心@EnableEurekaServer@SpringBootApplicationpublic class ServiceDiscoveryBootStrap { public static void main(String[] args) { new SpringApplicationBuilder(ServiceDiscoveryBootStrap.class).run(args); }}这是注册中心的配置文件 /src/main/resources/application.ymlserver: port: 1100eureka: client: # 设置是否从注册中心获取注册信息（缺省true） # 因为这是一个单点的EurekaServer，不需要同步其它EurekaServer节点的数据，故设为false fetch-registry: false # 设置是否将自己作为客户端注册到注册中心（缺省true） # 这里为不需要（查看@EnableEurekaServer注解的源码，会发现它间接用到了@EnableDiscoveryClient） register-with-eureka: false # 在未设置defaultZone的情况下，注册中心在本例中的默认地址就是http://127.0.0.1:1100/eureka/ # 但奇怪的是，启动注册中心时，控制台还是会打印这个地址的节点：http://localhost:8761/eureka/ # 而实际服务端注册时，要使用1100端口的才能注册成功，8761端口的会注册失败并报告异常 serviceUrl: # 实际测试：若修改尾部的eureka为其它的，比如/myeureka，注册中心启动没问题，但服务端在注册时会失败 # 报告异常：com.netflix.discovery.shared.transport.TransportException: Cannot execute request on any known server defaultZone: http://127.0.0.1:${server.port}/eureka/服务提供方01总体思路如下 SpringBoot启动类标注 @EnableEurekaClient 或者 @EnableDiscoveryClient 注解 配置注册中心地址ok，let`s drink code …这是服务提供方的 pom.xml&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;com.jadyer.demo&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;demo-cloud-02&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;artifactId&amp;gt;service-server-01&amp;lt;/artifactId&amp;gt; &amp;lt;properties&amp;gt; &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt; &amp;lt;/properties&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;这是服务提供方的 SpringBoot 启动类 ServiceServer01BootStarp.javapackage com.jadyer.demo;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;/** * 通过 @EnableEurekaClient 注解，为服务提供方赋予注册和发现服务的能力 * ------------------------------------------------------------------------------------------------------------------ * 也可以使用org.springframework.cloud.client.discovery.@EnableDiscoveryClient注解 * 详见以下两篇文章的介绍 * http://cloud.spring.io/spring-cloud-static/Camden.SR3/#_registering_with_eureka * https://spring.io/blog/2015/01/20/microservice-registration-and-discovery-with-spring-cloud-and-netflix-s-eureka * ------------------------------------------------------------------------------------------------------------------ * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/9 16:00. */@EnableEurekaClient@SpringBootApplicationpublic class ServiceServer01BootStarp { public static void main(String[] args) { new SpringApplicationBuilder(ServiceServer01BootStarp.class).run(args); }}这是服务提供方的配置文件 /src/main/resources/application.ymlserver: port: 2100spring: application: name: CalculatorServer # 指定发布的微服务名（以后调用时，只需该名称即可访问该服务）eureka: client: serviceUrl: defaultZone: http://127.0.0.1:1100/eureka/ # 指定服务注册中心的地址这是服务提供方暴露的数学运算服务 CalculatorController.javapackage com.jadyer.demo;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.cloud.client.ServiceInstance;import org.springframework.cloud.client.discovery.DiscoveryClient;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * 服务提供方暴露的数学运算服务 * Created by 玄玉&amp;lt;https://jadyer.cn/&amp;gt; on 2017/1/9 16:00. */@RestControllerpublic class CalculatorController { private final Logger logger = LoggerFactory.getLogger(getClass()); @Resource private DiscoveryClient client; @RequestMapping(&quot;/add&quot;) public int add(int a, int b){ //加运算 int result = a + b; //输出服务信息 ServiceInstance instance = client.getLocalServiceInstance(); logger.info(&quot;uri={}，serviceId={}，result={}&quot;, instance.getUri(), instance.getServiceId(), result); //返回结果 return result; }}服务提供方02除了启动端口为2200外，其代码与服务提供方01的完全相同验证先看一下注册中心的 Eureka 首页效果图可以看到：两个服务相同，启动端口不同的 CalculatorServer 已经注册进来了由于发布的微服务所暴露出去的都是 HTTP 的接口，所以验证的话，我们可以浏览器直接访问下面的两个地址http://127.0.0.1:2100/add?a=3&amp;amp;b=13http://127.0.0.1:2200/add?a=3&amp;amp;b=13目前为止，我们完成了 Spring Cloud Netflix Eureka 搭建注册中心的基本示例，不过也只是尝尝鲜因为它还存在着很多问题，比如 什么是自我保护模式 服务提供方关闭之后，在注册中心看到的状态还是 UP 注册中心的服务提供方显示的名字，是不是可以自定义 … …等等吧，这些问题，请参见 Eureka 进阶篇：https://jadyer.cn/2017/01/17/springcloud-eureka-advance/" }, { "title": "SpringCloud系列-01初识SpringCloud", "url": "/posts/springcloud-intro/", "categories": "SpringCloud", "tags": "SpringCloud", "date": "2020-01-09 12:10:00 +0800", "snippet": " 简介 版本名这是一个持续更新的、一些关于 SpringCloud 周边的文章比如它那不走寻常路的版本名、其各组件的功能描述等等简介提到 Spring Cloud，就不得不提微服务中，大名鼎鼎的 NetflixNetflix 开源了他们家久经实战考验的一系列微服务组件，而 Spring Cloud 又对其进行了一系列封装，使之更便于使用Spring Cloud 是在 Spring Boot 的基础上建立的它是一个包含了诸多子项目（Spring Cloud Bus、Spring Cloud Config、Spring Cloud Netflix）的大型综合项目其项目主页为：http://projects.spring.io/spring-cloud/目前主要包括但不限于以下功能： 配置管理（configuration management） 服务发现（service discovery，也就是服务注册中心） 断路器（circuit breakers，也叫熔断器） 智能路由（intelligent routing，通常用来做 API-Gateway 实现） 控制总线（control bus） 微代理（micro-proxy） 全局锁（global locks） 领导选举（leadership election） 一次性令牌（one-time tokens） 分布式会话（distributed sessions） 集群状态管理（cluster state）举个例子：比如 Spring Cloud 的子项目之一 Spring Cloud Netflix它封装 Netflix 公司开源的一系列产品，为 SpringBoot 应用提供了自配置的 Netflix OSS 整合比如：服务发现（Eureka）、断路器（Hystrix）、智能路由（Zuul）、客户端软负载均衡（Ribbon）等功能版本名目前，官网中会看到三个版本名：Angel、Brixton、Camden（注意我的用语是版本名，没说版本号）这是由于：SpringCloud 这个包含了诸多子项目的大型综合项目，它的各子项目版本号都是各自维护的于是为了管理子项目，避免混淆版本名与子项目版本号，才采用了命名的方式（这些命名目前来看是根据英文字母顺序表的）比如最先发布的综合版本叫做 Angel，接着就是 Brixton，现在到了 Camden（相信以后会更多，26个字母，应该足够用吧）而版本号后面的 .SR 指的是：service releases，简称 SRX（X 是一个递增数字）通过其官网下方的 Release train contents: 表格，可以看到目前各版本名所包含的子项目注意：关于其各版本与 Spring-Boot 版本之间的关系，也会在这里面看到 Component Angel.SR6 Brixton.SR7 Camden.SR4 Camden.BUILD-SNAPSHOT spring-cloud-aws 1.0.4.RELEASE 1.1.3.RELEASE 1.1.3.RELEASE 1.1.4.BUILD-SNAPSHOT spring-cloud-bus 1.0.3.RELEASE 1.1.2.RELEASE 1.2.1.RELEASE 1.2.2.BUILD-SNAPSHOT spring-cloud-cli 1.0.6.RELEASE 1.1.6.RELEASE 1.2.0.RC1 1.2.0.BUILD-SNAPSHOT spring-cloud-commons 1.0.5.RELEASE 1.1.3.RELEASE 1.1.7.RELEASE 1.1.8.BUILD-SNAPSHOT … … … … … … … … … … " }, { "title": "Linux入门", "url": "/posts/linux-os/", "categories": "LINUX", "tags": "LINUX", "date": "2019-10-19 12:10:00 +0800", "snippet": " RPM管理 任务调度 运行级别 启动过程 进程和线程RPM管理RPM（RedHat Package Manager）是一种用于互联网下载包的打包及安装工具，类似于Windows中的setup它会生成具有.rpm扩展名的文件，它包含在某些Linux分发版中，如OpenLinux、TurboLinux、S.u.S.E等等这一文件格式名称虽然打了RedHat的标志，但其原始设计理念是开放式的，目前可以算是公认的行业标准了下面是RPM的一些常用命令 rpm -qa：查询已安装的所有rpm软件包 rpm -q mysql：查询是否已安装mysql软件包 rpm -qi mysql：查询mysql软件包的信息 rpm -ql mysql：查询mysql软件包中的文件 rpm -qf 文件全路径名：查询文件所属的软件包 rpm -qp 包文件名：查询包的信息对这个软件包的介绍 rpm -U RPM包全路径名称：升级软件包，比如rpm -U cvs-1.11.2-10.i386.rpm rpm -i RPM包全路径名称：安装软件包到当前系统（i=install安装） rpm -ivh RPM包全路径名称：安装过程中显示提示信息（v=verbose提示，h=hash进度条） rpm -e RPM包的名称：卸载RPM包，比如rpm -e jdk即可卸载JDK说明：如果其它软件包依赖于所要卸载的软件包，那么卸载时就会产生错误信息比如rpm -e foo会提示removing these packages would break dependencies:foo is needed by bar-1.0-1这时我们可以使用--nodeps命令行选项，来让RPM忽略这个错误，并继续卸载，但显然这并不是一个好主意任务调度即系统在某个时间执行的特定的命令或程序，系统中的/etc/crontab文件指的就是任务调度文件通过crontab -l命令可以列出当前的任务调度，crontab -r可以终止任务，而设置任务的具体用法如下 通过命令crontab -e进入insert模式，然后输入05 * * * * date &amp;gt;&amp;gt; /opt/tomcat8.0.21/logs/mydate 保存并退出：:x，若看到控制台提示crontab: installing new crontab则表示定时调度任务分配完毕，等着执行就行了上面说的是单任务要是多任务，要么crontab -e时直接换行写第二个任务要么先把任务写到一个shell脚本里面，步骤如下 vim mytask.sh 输入两行任务：date &amp;gt;&amp;gt; /home/mydate22以及cp ../../backup/mpp.zip ./backup chmod 744 mytask.sh（默认的mytask.sh是没有x权限的，所以这里为该文件设定可执行的权限） crontab -e 进入insert模式后，输入0 2 * * * /opt/tomcat8.0.21/logs/mytask.sh命令即可运行级别可以使用runlevel命令查询系统的运行级别而决定着系统的默认运行级别的配置为：/etc/inittab文件中的id:5:initdefault:里面的数字常见的运行级别有以下几个 0：关机 1：单用户 2：多用户状态没有网络服务 3：多用户状态有网络服务（常用于公司服务器） 4：系统未使用保留给用户 5：图形界面（若系统设置为5号级别，则每次开机都会进入图形界面） 6：系统重启若不慎将运行级别设为6，这里以RedHat为例，描述一下解决办法当Linux重启进入GRUB引导界面时，即出现系统选择界面读秒时，按下键盘上的e键然后选中第二行（即kernel /vmlinuz-2.4.20-8 ro root=LABEL=/），再按下键盘的e键再输入1，此时显示的应为grub edit&amp;gt; kernel /vmlinuz-2.4.20-8 ro root=LABEL=/ 1输入1之后，回车，会返回GRUB引导界面，再按下b键，此时会重新启动并直接进入单用户模式切记：输入的1，与其前面的LABEL=/之间有一个空格这里1代表单用户级别，若输入其它级别的数字，是没有意义的，Linux仍会不断重启因为Linux在启动时，会读取/etc/inittab文件，并按照该文件指定的级别启动Linux而只有单用户级别，在启动时才不会读取/etc/inittab文件然后在单用户模式中修改/etc/inittab文件文件，而且该模式下还可以修改用户密码这有点像是Linux的漏洞，别人辛辛苦苦的工作结果，我们却可以在该模式下改掉它启动过程 BIOS自检（无论哪个操作系统都会执行该步骤） 启动GRUB/LILO 运行Linux内核并检测硬件 运行系统的第一个进程init init进程读取系统引导配置文件/ect/inittab中的信息进行初始化 /etc/rc.d/rc.sysinit：系统初始化脚本（这是一个很强大的文件，涉及到Linux内核，如果能读懂这个文件，将会很牛逼） /ect/rc.d/rcX.d/[KS]* - 根据运行级别X配置服务：终止以’K’开头的服务，启动以’S’开头的服务 /etc/rc.d/rc.local：执行本地特殊配置 其它特殊服务进程和线程进程就是正在执行的程序，每一个进程都会被分配一个ID号线程属于轻量级的进程，进程有独立的地址空间，线程则没有，Linux中叫fork，Windows中叫Thread并且线程不能独立存在，它是由进程创建的以下是几个进程查看的命令 kill -9 PID：强制干掉指定PID的进程 ps -a：显示当前终端的所有进程信息 ps -u：以用户的格式显示进程信息 ps -x：显示后台进程运行的参数（PID：进程识别号，TTY：终端机号，TIME：此进程所耗CPU的时间，COMMAND：正在执行的命令或进程名）" }, { "title": "vscode开发java", "url": "/posts/vscode-java/", "categories": "IDE, vscode", "tags": "RocketMQ", "date": "2019-08-08 14:10:00 +0800", "snippet": " 下载安装软件 [https://code.visualstudio.com/Download#] (个人电脑选择System版本) 配置终端默认cmd 配置cmd打开的编码格式为utf-8 创建profile（点击左下角齿轮-&amp;gt;profile） java 并设置为default ，后续插件安装都对于java这个profile 安装插件 IntelliJ IDEA Keybindings，Extension Pack for Java，Spring Boot Extension Pack，MybatisX，Lombok Annotations Support for VS Code 配置自动导包" }, { "title": "研习RocketMQ01之高可用与消息存储", "url": "/posts/rocketmq-base/", "categories": "中间件, 消息队列", "tags": "RocketMQ", "date": "2019-08-08 14:10:00 +0800", "snippet": " 高可用 可靠性 可用性 消息存储 commitlog 消费队列 实际消费 随机消费 重复消费 优化 常见的主流消息队列有以下三款，各自定位也有所不同 RocketMQ：高性能可靠消息传输 RabbitMQ：可靠消息传输 Kafka：系统间的数据流通道（海量的数据通过它走通道，比如大数据日志分析，要的就是大量数据的吞吐量）可以看出，RocketMQ 和 RabbitMQ 是扛业务流量的（属于OLTP），Kafka 偏重数据分析领域（属于OLAP）三者的区别，大体如下：支持分布式则说明扩展能力好，扩展能力好就能存很多消息，能存的消息多则表示堆积能力好堆积能力好就能更好的实现削峰填谷（即把请求先缓存在MQ，再慢慢消费，它考验的是 MQ 的堆积能力）   RocketMQ RabbitMQ Kafka 数据可靠性 高 高 高 性能 高 中 非常高 可用性 分布式、主从 主从 分布式、主从 堆积能力 非常好 一般 非常好 延时消息 只支持特定Level 死信队列实现 不支持 事务消息 支持 不支持 不支持 消息过滤 支持 不支持 支持 消息查询 支持 不支持 不支持 批量发送 不支持 不支持 支持 消费失败重试 支持 支持 不支持 高可用上面是 RocketMQ 的拓扑图和架构图，可以看出，它主要有四个结构： NameServer：集群管理 Broker：存储消息 Producer：生产者 Consumer：消费者其特点如下： 每组Broker都是主从部署的，且都会注册自身信息到nameserver 每组Broker之间是没有数据同步的（即各个master之间都是独立的） 消费消息时，consumer会从nameserver获取topic所在的broker信息，然后建立broker连接，消费消息 生产消息时，producer会从nameserver获取可以存储topic的borker信息，然后建立broker连接，投递消息 producer只会把消息投递到主broker（不会投递到从），而consumer则主从都会去消费（这是高可用的一个手段） nameserver集群的各个节点之间相互独立，且无任何的数据通信（它们并不知道彼此的存在）所以broker在注册时要注册到nameserver的所有节点上，不过nameserver节点很少，再加上还有hearbeat即便注册失败，还会通过心跳不停的注册来保证nameserver的数据一致性（所以它的节点很快就对齐了）同样，在做服务发现时，随便连到某一个节点上就可以找到broker了虽然nameserver集群的实现方式有点偷懒，但broker节点的变化频率并不高，所以这并不会消耗过多的资源而其分布式就体现在：可以很方便的扩展出一组Broker，然后注册到NameServer所以说它的堆积能力强就是这个原因（现有的Broker写满了，可以很方便的扩出一组来，扩展性非常好）可靠性数据可靠，无非就是说数据不丢这通常要从两个角度来看：固化（即刷盘，保证本地的数据可靠）和同步（即broker的主从部署，避免单点）固化方式有两种： 同步刷盘：性能低，可靠性高　　　　　消息到达broker后，就先写到磁盘上，然后才会返回给producer说消息发送成功 异步刷盘：性能高，可靠性低　　　　　消息到达broker后，先在缓冲区攒着，然后直接返回给producer说消息发送成功　　　　　具体刷盘的动作，是由异步线程在触发了某个阈值之后，再把缓冲区数据写到磁盘　　　　　这个阈值一般就是时间和空间（每隔多长时间写一次，空间达到多少写一次）　　　　　而丢数据的话，最多也就是丢两次刷盘之间的数据，但是性能高 通过刷盘，保证了本地的数据的可靠，但这还不够，因为分布式系统，就要避免单点现在主库的数据可靠了，那从库呢（或者说多副本）？所以要做到一致性写入，就得来看一下数据同步的方式同步方式也有两种： 同步双写：性能低，可靠性高（比如master挂了，没关系，slave有全量消息，能保证被消费） 异步复制：性能高，可靠性低实际部署时，除了根据数据一致性的要求来选择不同的固化和同步方式外，还要考虑机柜部署这种存储产品时，两台机器都不会放到同一个机柜里面，而是各自独立放在不同的机柜因为机柜同时掉电的概率太低了，这就等于是间接的保证了可靠性（也就没必要非得同步刷盘同步双写了）实际生产环境用的异步写更多一些可用性这里有一个很重要点：broker主从模式如果master宕机，那么broker就会变成可读不可写的状态这个特性能保证mstaer剩余未消费的消息，通过slave得到消费（消费的偏移量也会同步到slave）对于未同步到slave的消息，如果此时broker可写的话，那么这些消息就会被跳过，就会造成它丢了所以此时要求slave不可写，除非我们人为的把slave提升成master对于broker的集群搭建方式，有以下不同： 单master模式（相当于线下的测试环境，它没什么可用性，挂了就挂了） 多master模式（可用性稍好些，但若挂了一个master，里面数据容易丢，所以这个模式意义不大） 多master多slave模式（具体固化和同步方式，根据实际情况选择）消息存储这里有几个概念： CommitLog：存储消息主体（虽然名字里有log，但不是日志，它存的是消息数据） ConsumeQueue：消息消费队列 IndexFile：消息索引文件（它跟存储没啥太大关系，是给运维用的）commitlog所有producer生产的消息，都会追加写到commitlog里面注意：这里是谁先到commitlog，谁就先写进去，保证了它是顺序写的所以可能会出现：前俩消息是 topic1 的，第三个是 topic2 的，第四个是 topic1 的，第五六个是 topic2 的交叉情形消费队列由于commitlog并没有做什么优化（比如按照topic分类），所以就有了消费队列在追加写commitlog的过程中，dispatch线程会按照偏移量一点点往下分发每来一个消息，它都会根据topic来把消息分发到某个队列里面（注意是某个队列，不是所有队列）而且一个topic可以对应到多个队列，具体分发给哪个队列则由负载均衡决定（该方案是在producer端做的）这样一来，消息的写入和消费就会很快，因为它不是由固定队列来承担某个topic的所有消息，而是分摊的实际消费队列里存的不是消息实体（如果存消息内容，那commitlog也就没啥意义了）而是消息的索引（即该消息在commitlog里的偏移量，以及消息实体的大小，和tags）所以实际消费时就会根据偏移量到commitlog找到消息，然后取出消息内容，接着被消费端消费随机消费这里就有一个问题：topic是顺序写的，而消费则不是顺序消费的即同一个topic连续投递过来的两个顺序消息，可能会被分发到不同的队列，导致消费不一定是连续的所以会出现topic是顺序写到commitlog的，而消费则是在commitlog的一段范围内随机读的虽然顺序写随机读这个问题，不如顺序读性能高，但其实影响不是很大（只是在做时间轮时有点影响）重复消费它只保证消息不丢，但不保证消息不重复因为consumer在从消费队列取数据时，不是一条一条取的，而是一次取 N 条，然后去慢慢消费若这个过程中consumer挂了，那么下次消费时，所取的数据还是会包括这一次的消息直到consumer显式的回复 ack 给消费队列，消费队列才会去偏移（即移动offset）所以，如果我们不能接受重复消息，那就得做幂等优化如果有优化需求，可以考虑从以下三个角度着手： CommitLog文件切分（默认1G）假设某业务堆积了很多消息，然后它突然开始消费，此时堆积消息可能位于commitlog的中部或顶部那么就要加载一个很大的文件来读到那些堆积消息（代价有点大），所以做切分，按需加载就行了 MMap提升文件访问性能内存文件映射机制，可以认为它做了一次类似于零拷贝，减少了内核态和用户态的切换其实就是对写入做了一次优化，多次读直接读内存，减少了系统调用 SSD（就算是普通的机械盘，一般也不会有什么性能问题）" }, { "title": "博客编写入门手册", "url": "/posts/%E5%8D%9A%E5%AE%A2%E7%BC%96%E5%86%99%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/", "categories": "使用指南, 博客", "tags": "博客", "date": "2019-08-08 12:10:00 +0800", "snippet": "This post will guide you how to write a post on Chirpy theme. Even if you have previous experience with Jekyll, this article is worth reading, because many features require specific variables to be set.Naming and PathCreate a new file named YYYY-MM-DD-TITLE.EXTENSION and put it in the _posts of the root directory. Please note that the EXTENSION must be one of md and markdown. If you want to save time of creating files, please consider using the plugin Jekyll-Compose to accomplish this.Front MatterBasically, you need to fill the Front Matter as below at the top of the post:---title: TITLEdate: YYYY-MM-DD HH:MM:SS +/-TTTTcategories: [TOP_CATEGORIE, SUB_CATEGORIE]tags: [TAG] # TAG names should always be lowercase--- The posts’ layout has been set to post by default, so there is no need to add the variable layout in the Front Matter block.Timezone of DateIn order to accurately record the release date of a post, you should not only set up the timezone of _config.yml but also provide the post’s timezone in variable date of its Front Matter block. Format: +/-TTTT, e.g. +0800.Categories and TagsThe categories of each post are designed to contain up to two elements, and the number of elements in tags can be zero to infinity. For instance:---categories: [Animal, Insect]tags: [bee]---Author InformationThe author information of the post usually does not need to be filled in the Front Matter , they will be obtained from variables social.name and the first entry of social.links of the configuration file by default. But you can also override it as follows:---author: name: Full Name link: https://example.com---Table of ContentsBy default, the Table of Contents (TOC) is displayed on the right panel of the post. If you want to turn it off globally, go to _config.yml and set the value of variable toc to false. If you want to turn off TOC for a specific post, add the following to the post’s Front Matter:---toc: false---CommentsThe global switch of comments is defined by variable comments.active in the file _config.yml. After selecting a comment system for this variable, comments will be turned on for all posts.If you want to close the comment for a specific post, add the following to the Front Matter of the post:---comments: false---MathematicsFor website performance reasons, the mathematical feature won’t be loaded by default. But it can be enabled by:---math: true---MermaidMermaid is a great diagrams generation tool. To enable it on your post, add the following to the YAML block:---mermaid: true---Then you can use it like other markdown languages: surround the graph code with ```mermaid and ```.ImagesCaptionAdd italics to the next line of an image，then it will become the caption and appear at the bottom of the image:![img-description](/path/to/image)_Image Caption_SizeIn order to prevent the page content layout from shifting when the image is loaded, we should set the width and height for each image:![Desktop View](/assets/img/sample/mockup.png){: width=&quot;700&quot; height=&quot;400&quot; }Starting from Chirpy v5.0.0, height and width support abbreviations (height → h, width → w). The following example has the same effect as the above:![Desktop View](/assets/img/sample/mockup.png){: w=&quot;700&quot; h=&quot;400&quot; }PositionBy default, the image is centered, but you can specify the position by using one of the classes normal, left, and right. Once the position is specified, the image caption should not be added. Normal position Image will be left aligned in below sample: ![Desktop View](/assets/img/sample/mockup.png){: .normal } Float to the left ![Desktop View](/assets/img/sample/mockup.png){: .left } Float to the right ![Desktop View](/assets/img/sample/mockup.png){: .right } ShadowThe screenshots of the program window can be considered to show the shadow effect, and the shadow will be visible in the light mode:![Desktop View](/assets/img/sample/mockup.png){: .shadow }CDN URLIf you host the images on the CDN, you can save the time of repeatedly writing the CDN URL by assigning the variable img_cdn of _config.yml file:img_cdn: https://cdn.comOnce img_cdn is assigned, the CDN URL will be added to the path of all images (images of site avatar and posts) starting with /.For instance, when using images:![The flower](/path/to/flower.png)The parsing result will automatically add the CDN prefix https://cdn.com before the image path:&amp;lt;img src=&quot;https://cdn.com/path/to/flower.png&quot; alt=&quot;The flower&quot;&amp;gt;Image PathWhen a post contains many images, it will be a time-consuming task to repeatedly define the path of the images. To solve this, we can define this path in the YAML block of the post:---img_path: /img/path/---And then, the image source of Markdown can write the file name directly:![The flower](flower.png)The output will be:&amp;lt;img src=&quot;/img/path/flower.png&quot; alt=&quot;The flower&quot;&amp;gt;Preview ImageIf you want to add an image to the top of the post contents, specify the attribute src, width, height, and alt for the image:---image: src: /path/to/image/file width: 1000 # in pixels height: 400 # in pixels alt: image alternative text---Except for alt, all other options are necessary, especially the width and height, which are related to user experience and web page loading performance. The above section “Size” also mentions this.Starting from Chirpy v5.0.0, the attributes height and width can be abbreviated: height → h, width → w. In addition, the img_path can also be passed to the preview image, that is, when it has been set, the attribute src only needs the image file name.Pinned PostsYou can pin one or more posts to the top of the home page, and the fixed posts are sorted in reverse order according to their release date. Enable by:---pin: true---PromptsThere are several types of prompts: tip, info, warning, and danger. They can be generated by adding the class prompt-{type} to the blockquote. For example, define a prompt of type info as follows:&amp;gt; Example line for prompt.{: .prompt-info }SyntaxInline Code`inline code part`Filepath Hightlight`/path/to/a/file.extend`{: .filepath}Code BlockMarkdown symbols ``` can easily create a code block as follows:```This is a plaintext code snippet.```Specifying LanguageUsing ```{language} you will get a code block with syntax highlight:```yamlkey: value``` The Jekyll tag {% highlight %} is not compatible with this theme.Line NumberBy default, all languages except plaintext, console, and terminal will display line numbers. When you want to hide the line number of a code block, add the class nolineno to it:```shellecho &#39;No more line numbers!&#39;```{: .nolineno }Specifying the FilenameYou may have noticed that the code language will be displayed at the top of the code block. If you want to replace it with the file name, you can add the attribute file to achieve this:```shell# content```{: file=&quot;path/to/file&quot; }Liquid CodesIf you want to display the Liquid snippet, surround the liquid code with {% raw %} and {% endraw %}:{% raw %}```liquid{% if product.title contains &#39;Pack&#39; %} This product&#39;s title contains the word Pack.{% endif %}```{% endraw %}Or adding render_with_liquid: false (Requires Jekyll 4.0 or higher) to the post’s YAML block.Learn MoreFor more knowledge about Jekyll posts, visit the Jekyll Docs: Posts." }, { "title": "Git常用命令", "url": "/posts/git-command/", "categories": "使用指南, GIT", "tags": "GIT", "date": "2019-05-08 12:10:00 +0800", "snippet": " 一机多SSHkey自动切换 重置passphrase 仅克隆最后两个版本 拉取仓库以及分支操作 提交本地新项目到Gitlab 仓库迁移 操作Tag 还原文件一机多SSHkey自动切换对于同时处理个人Github和公司Gitlab的情况，就需要一台机器同时管理两个SSHkey并能够自动切换详细原理见http://www.ixirong.com/2015/07/29/how-to-use-github-gitlab-together/，这里直接说结果实现方式：通过SSH协议配置config文件，不同域名采用不同的认证密钥下面举例：配置全局的用户为Github用户，团队项目Gitlab采用局部配置# 全局配置，Github默认使用此配置，执行完后可在 ~/.gitconfig 文件中看到设置的用户信息$ git config --global user.name &#39;leoz&#39; &amp;amp;&amp;amp; git config --global user.email &#39;leoz.space@qq.com&#39;# 局部配置，每个项目都需在项目源码的 .git 目录下执行，执行完后可在 .git/config 文件中看到设置的用户信息$ git config --local user.name &#39;xuanyu&#39; &amp;amp;&amp;amp; git config --local user.email &#39;xuanyu@company.com&#39;# 生成供 gitee 使用的 ssh key$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitee -C &quot;leoz.space@qq.com&quot;# 生成供 gitlab 使用的 ssh key$ ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitlab -C &quot;xuanyu@company.com&quot;# 生成供 github 使用的默认的 ssh key$ ssh-keygen -t rsa -C &quot;leoz.space@qq.com&quot;再看 ~/.ssh/ 目录下（Windows一般为 C:\\Users\\leoz\\.ssh\\）有没有config文件若没有，就新建 touch ~/.ssh/config，并添加如下内容Host gitee.com IdentityFile ~/.ssh/id_rsa.gitee User leozHost gitlab.company.com IdentityFile ~/.ssh/id_rsa.gitlab User xuanyu然后将 publicKey 分别上传 github（id_rsa.pub）、gitee.com（id_rsa.gitee.pub）、gitlab（id_rsa.gitlab.pub）再执行下面的命令，进行验证$ ssh -T git@github.comHi leoz! You&#39;ve successfully authenticated, but GitHub does not provide shell access.$ ssh -T git@gitee.comHi 玄玉! You&#39;ve successfully authenticated, but GITEE.COM does not provide shell access.$ ssh -T git@gitlab.company.comWelcome to GitLab, 玄玉!重置passphrasepassphrase指的是生成RSA密钥时使用的密码，重置时必须输入原密码，否则不能重置所以若忘了passphrase，就杯具了，这时候只能重新生成RSA密钥对，再重新上传Gitlab这里主要参考了万能的stackoverflow$ ssh -T git@gitlab.company.comEnter passphrase for key &#39;/c/Users/leoz/.ssh/id_rsa.gitlab&#39;:Welcome to GitLab, 玄玉!$ ssh-keygen -f ~/.ssh//id_rsa.gitlab -pEnter old passphrase:Enter new passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved with the new passphrase.$ ssh -T git@gitlab.company.comWelcome to GitLab, 玄玉!仅克隆最后两个版本$ git clone https://github.com/leoz/seed.git --depth=2Cloning into &#39;seed&#39;...remote: Counting objects: 249, done.remote: Compressing objects: 100% (195/195), done.remote: Total 249 (delta 58), reused 148 (delta 27), pack-reused 0Receiving objects: 100% (249/249), 484.00 KiB | 33.00 KiB/s, done.Resolving deltas: 100% (58/58), done.Checking connectivity... done.$ cd seed/$ git rev-list master --max-count=100af3137946011e8924c152fec86b8610368512d400e01709d85a4dd5b2d75d2eeab6933d6a4bdf0c$ git log --pretty=oneline0af3137946011e8924c152fec86b8610368512d4 [^] set donot push msg to user phone on WeChat00e01709d85a4dd5b2d75d2eeab6933d6a4bdf0c [+] set donot push msg to user phone拉取仓库以及分支操作# 直接克隆（默认只会拉取远程的master分支代码）$ git clone http://git.yourcompany.cn/open/mpp.git# 克隆指定分支代码（此时拉取下来后，本地分支名称是与远程相同的，并且无法做到拉取之前自定义本地分支名称）$ git clone -b remote_branch_name http://git.yourcompany.cn/open/mpp.git# 创建并切换至本地分支develop，同时关联远程origin/develop分支（本地develop分支的初始代码与远程origin/develop分支的初始代码相同）$ git checkout -b develop origin/develop# 切换到本地的master分支$ git checkout master# 切换到本地的develop分支$ git checkout develop# 根据COMMIT-ID创建一个新的本地分支，并立即切换到这个新的本地分支，最后提交到远程$ git clone -b feature/v1.3.2 http://git.yourcompany.com/open/mpp.git$ git cd mpp/$ git checkout -b release/demo a936a17720bceb201a701bf3972a856c69c3b0fa$ git push origin release/demo:release/demo# 查看当前项目的远程git地址$ git remote -vorigin git@git.yourcompany.cn:open/mpp.git (fetch)origin git@git.yourcompany.cn:open/mpp.git (push)# 查看当前项目的本地的所有git分支（打印的绿色文字表示当前所在分支，或者看前面有星号表示）$ git branch master* mpp_v2.8.0# 查看当前项目的远程的所有分支列表# 注：clone时若使用了--depth=2（即只克隆了最后两个版本的），则此处有可能只会打印部分的远程分支列表$ git branch -r remotes/origin/HEAD -&amp;gt; origin/master remotes/origin/master remotes/origin/mpp_v2.7.0.1 remotes/origin/mpp_v2.8.0# 查看当前项目的、包含本地和远程的、所有分支列表（打印的绿色文字表示当前所在的本地分支，红色文字表示远程的所有分支列表）# 注：clone时若使用了--depth=2（即只克隆了最后两个版本的），则此处有可能只会打印部分的远程分支列表$ git branch -a master* mpp_v2.8.0 remotes/origin/HEAD -&amp;gt; origin/master remotes/origin/master remotes/origin/mpp_v2.7.0.1 remotes/origin/mpp_v2.8.0提交本地新项目到Gitlab$ cd existing_folder$ git init$ cd .git/$ git config --local user.name &#39;leoz&#39; &amp;amp;&amp;amp; git config --local user.email &#39;leoz.space@qq.com&#39;# 解决提交文件时报告warning: LF will be replaced by CRLF的问题# $ git config --local core.autocrlf false$ cd ..$ git remote add origin git@git.yourcompany.cn:open/mpp.git$ git pull origin master$ git add -A$ git commit -am &quot;init commit&quot;$ git push -u origin master仓库迁移# 先把所有未保存的修改打包为一个commit$ git commit -m &quot;change repository&quot;# 删掉原来git源$ git remote remove origin# 将新源地址写入本地版本库配置文件$ git remote add origin [YOUR NEW .GIT URL]# 提交所有代码$ git push -u origin master操作Tag# 拉取远程最新内容$ git fetch originFrom gitlab.leoz.com:open/mpp * [new branch] my-test-bran -&amp;gt; origin/my-test-bran * [new tag] 11 -&amp;gt; 11# 拉取远程指定的标签$ git fetch origin tag 22From gitlab.leoz.com:open/mpp * [new tag] 22 -&amp;gt; 22# 查看已拉取到本地的所有分支（-a参数可以将远程分支通过红色显示出来，如果你开了颜色支持）$ git branch -a develop* master remotes/origin/HEAD -&amp;gt; origin/master remotes/origin/branch-alipay-robot remotes/origin/branch-alipay-sw remotes/origin/develop remotes/origin/master remotes/origin/my-test-bran# 查看本地所有标签$ git tag1.6.5.RELEASE1.6.6.RELEASE# 查看本地某一类标签$ git tag -l *.6.R*1.6.6.RELEASE$ git tag | grep 6.R1.6.6.RELEASE# 查看本地某一个标签的详细信息$ git show 1.6.6.RELEASEtag 1.6.6.RELEASETagger: leoz &amp;lt;leoz.space@qq.com&amp;gt;Date: Thu Nov 3 11:30:05 2016 +08001、微信后台增加操作员管理功能2、微信参数二维码增加推送动态景点功能commit 696e291cfdac6ca05a711acaf90e79f97cb1128fAuthor: leoz &amp;lt;leoz.space@qq.com&amp;gt;Date: Thu Nov 3 11:08:44 2016 +0800 [^] 推广二维码扫描后的提示语改为分期不等待diff --git a/mpp-mgr/src/main/java/com/leoz/mpp/mgr/mpp/WeixinController.java b/mpp-mgr/src/main/java/com/leoz/mpp/mgr/mpp/WeixinController.javaindex 1d41739..2209e09 100644--- a/mpp-mgr/src/main/java/com/leoz/mpp/mgr/mpp/WeixinController.java+++ b/mpp-mgr/src/main/java/com/leoz/mpp/mgr/mpp/WeixinController.java@@ -220,7 +220,7 @@ public class WeixinController extends WeixinMsgControllerCustomServiceAdapter { StringBuilder sb = new StringBuilder(); sb.append(&quot;欢迎来到&quot;) .append(compInfoDto.getSuppCompBasicDto().getCompName())- .append(&quot;，美丽不等待，点击&amp;lt;a href=&#39;&quot;)+ .append(&quot;，旅游不等待，点击&amp;lt;a href=&#39;&quot;)^M .append(ConfigUtil.INSTANCE.getProperty(&quot;wechat.url.loan&quot;))# 创建本地标签$ git tag -a 1.6.7.RELEASE -m &#39;the tag of create&#39;$ git tag -a 1.6.8.RELEASE -m &#39;the tag of create again&#39;$ git tag -a 1.6.9.RELEASE -m &#39;the tag of create again again&#39;# Push本地所有标签到远程$ git push --tagsCounting objects: 2, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 396 bytes | 0 bytes/s, done.Total 2 (delta 0), reused 0 (delta 0)To git@gitlab.leoz.com:open/mpp.git * [new tag] 1.6.7.RELEASE -&amp;gt; 1.6.7.RELEASE * [new tag] 1.6.8.RELEASE -&amp;gt; 1.6.8.RELEASE# Push本地指定标签到远程$ git push origin 1.6.9.RELEASECounting objects: 1, done.Writing objects: 100% (1/1), 167 bytes | 0 bytes/s, done.Total 1 (delta 0), reused 0 (delta 0)To git@gitlab.leoz.com:open/mpp.git * [new tag] 1.6.9.RELEASE -&amp;gt; 1.6.9.RELEASE# 删除本地标签$ git tag1.6.5.RELEASE1.6.6.RELEASE1.6.7.RELEASE1.6.8.RELEASE1.6.9.RELEASE$ git tag -d 1.6.9.RELEASEDeleted tag &#39;1.6.9.RELEASE&#39; (was ea201ff)$ git tag1.6.5.RELEASE1.6.6.RELEASE1.6.7.RELEASE1.6.8.RELEASE# 删除远程标签$ git push origin --delete tag 1.6.8.RELEASETo git@gitlab.msxf.com:open/mpp.git - [deleted] 1.6.8.RELEASE$ git push origin :refs/tags/1.6.9.RELEASETo git@gitlab.leoz.com:open/mpp.git - [deleted] 1.6.9.RELEASE还原文件SVN中使用命令 svn revert &amp;lt;filename&amp;gt;Git中使用命令 git checkout &amp;lt;filename&amp;gt;（注意 git checkout . 会还原当前目录下的所有文件）" } ]
